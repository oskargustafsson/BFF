<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"event-emitter.js.html":{"id":"event-emitter.js.html","title":"Source: event-emitter.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Source: event-emitter.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; function moduleFactory() { /** * A mixin, providing event emitting capabilities to an object. Events are simply strings. When they are emitted, zero or more parameters can be passed as arguments to the listening functions. * @exports bff/event-emitter * @mixin */ var eventEmitter = { /** * Emit an event. Callbacks will be called with the same arguments as this function was called with, except for the event name argument. * @instance * @arg {string} eventName - Identifier string for the event. * @arg {...any} [eventArguments] - Zero or more arguments that event listeners will be called with. */ emit: function (eventName) { if (RUNTIME_CHECKS &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (!this.__private || !this.__private.listeners) { return; } var listenersForEvent = this.__private.listeners[eventName]; if (!listenersForEvent) { return; } for (var i = 0, n = listenersForEvent.length; i &lt; n; ++i) { var listener = listenersForEvent[i]; // Call the listener without the first item in the &quot;arguments&quot; array listener.call.apply(listener, arguments); } }, /** * Emit an event. Callbacks will be called with arguments given as an an array in the second argument * @instance * @arg {string} eventName - Identifier string for the event. * @arg {array} [argsArray] - An array of arguments with which the callbacks will be called. Each item in * the array will be provided as an individual argument to the callbacks. */ emitArgsAsArray: function (eventName, argsArray) { if (RUNTIME_CHECKS) { if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (arguments.length &gt; 1 &amp;&amp; (!argsArray || argsArray.length === undefined)) { throw '&quot;argsArray&quot; must have a length property'; } } if (!this.__private || !this.__private.listeners) { return; } var listenersForEvent = this.__private.listeners[eventName]; if (!listenersForEvent) { return; } for (var i = 0, n = listenersForEvent.length; i &lt; n; ++i) { listenersForEvent[i].apply(undefined, argsArray); } }, /** * Add an event listener function that will be called whenever the given event is emitted. Trying to add the exact same function twice till throw an error, as that is rarely ever the intention and a common source of errors. * @instance * @arg {string} eventName - Identifier string for the event that is to be listened to. * @arg {function} callback - The function that will be called when the event is emitted. */ addEventListener: function (eventName, callback) { if (RUNTIME_CHECKS) { if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; } } this.__private || Object.defineProperty(this, '__private', { writable: true, value: {}, }); var listeners = this.__private.listeners || (this.__private.listeners = {}); var listenersForEvent = listeners[eventName] || (listeners[eventName] = []); if (RUNTIME_CHECKS &amp;&amp; listenersForEvent.indexOf(callback) !== -1) { throw 'This listener has already been added (event: ' + eventName + ')'; } listenersForEvent.push(callback); }, /** * Removes an event listener function. If the function was never a listener, do nothing. * @instance * @arg {string} eventName - Identifier string for the event in question. * @arg {function} [callback] - If not given, all event listeners to the provided eventName will be removed. If given, only the given callback will be removed from the given eventName. */ removeEventListener: function (eventName, callback) { if (RUNTIME_CHECKS) { if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (arguments.length === 2 &amp;&amp; typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; // Catch a common cause of errors } } // No listeners at all? We are done. if (!this.__private || !this.__private.listeners) { return; } var listenersForEvent = this.__private.listeners[eventName]; if (!listenersForEvent) { return; } // No listeners for this event? We are done. if (callback) { var pos = listenersForEvent.indexOf(callback); if (pos === -1) { return; } listenersForEvent.splice(pos, 1); } else { listenersForEvent.length = 0; } listenersForEvent.length === 0 &amp;&amp; (delete this.__private.listeners[eventName]); }, }; return eventEmitter; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.eventEmitter = moduleFactory(); } }()); × Search results Close "},"event-listener.js.html":{"id":"event-listener.js.html","title":"Source: event-listener.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Source: event-listener.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; function moduleFactory() { function filterList(listeningToList, eventName, eventEmitter) { var length = listeningToList.length; for (var i = length - 1; i &gt;= 0; --i) { var listeningTo = listeningToList[i]; if (!eventEmitter || listeningTo.emitter === eventEmitter) { listeningTo.emitter.removeEventListener(eventName, listeningTo.callback); listeningToList.splice(i, 1); } } } function setupListeners(self, eventEmitter, eventName, callback, context, useCapture) { if (RUNTIME_CHECKS) { if (!eventEmitter.addEventListener) { throw '&quot;eventEmitter&quot; argument must be an event emitter'; } if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } } self.__private || Object.defineProperty(self, '__private', { writable: true, value: {}, }); var listeningTo = self.__private.listeningTo || (self.__private.listeningTo = {}); var listeningToEvent = listeningTo[eventName] || (listeningTo[eventName] = []); callback = callback.bind(context || self); listeningToEvent.push({ callback: callback, emitter: eventEmitter }); eventEmitter.addEventListener(eventName, callback, useCapture); } /** * A mixin, providing event listening capabilities to an object. This is an inversion-of-control with regards to regular event listening; the listener maintains a list of the events it is listening to. This allows the listener to remove some or all its event listeners, for instance when it is disabled or destroyed. This is an easy way to avoid leaking listeners. Caveat: don't mix eventEmitter.removeEventListener and eventListener.stopListening throughout a project, as that could result in memory leaks. * @exports bff/event-listener * @mixin */ var eventListener = { /** * Start listening to an event on a specified event emitting object. Both eventEmitters and eventNames arguments can be arrays. The total amount of listeners added will be the Cartesian product of the two lists. * @instance * @arg {Object|Array|NodeList} eventEmitters - One or more event emitters that will be listened to. * @arg {string|Array} eventNames - One or more string identifiers for events that will be listented to. * @arg {function} callback - The function that will be called when the event is emitted. * @arg {any} [context] - The context with which the callback will be called (i.e. what &quot;this&quot; will be). * Will default to the caller of .listenTo, if not provided. */ listenTo: function (eventEmitters, eventNames, callback, context, useCapture) { if (RUNTIME_CHECKS) { if (!eventEmitters || !(eventEmitters.addEventListener || eventEmitters instanceof Array)) { throw '&quot;eventEmitters&quot; argument must be an event emitter or an array of event emitters'; } if (typeof eventNames !== 'string' &amp;&amp; !(eventNames instanceof Array)) { throw '&quot;eventNames&quot; argument must be a string or an array of strings'; } if (typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; } if (arguments.length &gt; 4 &amp;&amp; typeof useCapture !== 'boolean') { throw '&quot;useCapture&quot; argument must be a boolean value'; } } // Convenience functionality that allows you to listen to all items in an Array or NodeList // BFF Lists have this kind of functionality built it, so don't handle that case here eventEmitters = eventEmitters instanceof Array || (typeof NodeList !== 'undefined' &amp;&amp; eventEmitters instanceof NodeList) ? eventEmitters : [ eventEmitters ]; eventNames = eventNames instanceof Array ? eventNames : [ eventNames ]; for (var i = 0; i &lt; eventEmitters.length; ++i) { for (var j = 0; j &lt; eventNames.length; ++j) { setupListeners(this, eventEmitters[i], eventNames[j], callback, context, !!useCapture); } } }, /** * Stop listening to events. If no arguments are provided, the listener removes all its event listeners. Providing any or both of the optional arguments will filter the list of event listeners removed. * @instance * @arg {Object} [eventEmitter] - If provided, only callbacks attached to the given event emitter will be removed. * @arg {string} [eventName] - If provided, only callbacks attached to the given event name will be removed. */ stopListening: function (eventEmitter, eventName) { if (RUNTIME_CHECKS) { if (!!eventEmitter &amp;&amp; !eventEmitter.addEventListener) { throw '&quot;eventEmitter&quot; argument must be an event emitter'; } if (arguments.length &gt; 1 &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } } if (!this.__private || !this.__private.listeningTo) { return; } // Not listening to anything? We are done. var eventNames = eventName ? {} : this.__private.listeningTo; eventName &amp;&amp; (eventNames[eventName] = true); for (eventName in eventNames) { var listeningToList = this.__private.listeningTo[eventName]; if (!listeningToList) { continue; } filterList(listeningToList, eventName, eventEmitter); listeningToList.length || (delete this.__private.listeningTo[eventName]); } }, }; return eventListener; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.eventListener = moduleFactory(); } }()); × Search results Close "},"extend.js.html":{"id":"extend.js.html","title":"Source: extend.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Source: extend.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; /** * ## bff/extend * @module bff/extend */ function moduleFactory() { var TYPES = [ 'object', 'array', 'function', 'string', 'number', 'boolean', 'null', 'undefined' ]; var SOLVERS; function getType(item) { return item === null ? 'null' : item instanceof Array ? 'array' : typeof item; } function getSolverFunction(val) { return getType(val) === 'function' ? val : SOLVERS[val]; } /** * @callback module:bff/extend~conflictSolver * @param {Object} target * @param {Object} source * @param {string} prop - The name of the conflicting property. * @param {string|module:bff/extend~conflictSolver|Object} onConflict - The same onConflict argumet passed to the extend() call. * @param {string|module:bff/extend~conflictSolver} defaultOnConflict - The same defaultOnConfluct argumet passed to the extend() call. */ /** * A function that extends a target object with the properties of a source object, with options for describing property collision behavior. Note that the target object is mutated and returned, i.e. no new object gets created by invoking this function. * * The function comes with a set of named built-in conflict-solving functions: * * _crash_: Throws an error when a property conflict occurs. This is the default solver function. * * _useTarget_: Uses the target's property, i.e. leaves the target property unchanged. * * _useSource_: Uses the source's property, i.e. overwrites the target property with the source property. * * _merge_: Tries to merge the values in an intuitive way. * * Objects are merged recursively. * * Arrays are concatenated. * * Functions are combined, so that the target's function is first called, then the source's. Both functions are passed the same arguments. * * Numbers and strings added using the + operator. * * Boolean values are or:ed using the || operator (i.e. Boolean addition). * * If the source and target types are not the same, use the source value. * The caller also has the option to specify custom solver functions. * * **Examples** * ```javascript * extend( * { a: { b: 'b', c: 'c' } }, * { a: { c: 'c', d: 'd' } }, * 'useSource'); * // Returns { a: { c: 'c', d: 'd' } } * ``` * As can be seen in above, the 'useSource' conflict solver is not recursive, it simply overwrites any property it encounters. This is how e.g. jQuery.extend and _.assign behaves. * ```javascript * extend( * { a: { b: 'b', c: 'c' } }, * { a: { c: 'c', d: 'd' } }, * 'merge'); * // Returns { a: { b: 'b', c: 'c', d: 'd' } } * ``` * Here we see that the 'merge' solver works recursively. * ```javascript * extend( * { a: { b: 'b' }, num: 1 }, * { a: { c: 'c' }, num: 2 }, * { object: 'merge' }, 'useSource'); * // Returns { a: { b: 'b', c: 'c' }, num: 2 } * ``` * The above example uses the 'merge' solver on objects and the 'useSource' solver on all other property types. This produces a recursive behavior over objects, which is quite often desired. This is how e.g. _.merge behaves * ```javascript * extend( * { a: { b: 'b' }, num: 1 }, * { a: { c: 'c' }, num: 2, newProp: 3 }, * function (target, source, prop) { target[prop] = 42; }); * // Returns { a: 42, num: 42, newProp: 3 } * ``` * Above we see a (fairly useless) custom conflict solver function. * @alias module:bff/extend * @arg {Object} target - The object that will be extende with new properties. * @arg {Object} source - The object that provides the new properties. * @arg {string|module:bff/extend~conflictSolver|Object} [onConflict] - Specifies how to handle cases where a property exists both on the target and on the source. * * a _string_ argument will be used to identify one of the built in solver functions. Valid values are 'useTarget', 'useSouce', 'crash' and 'merge'. * * a _function_ argument will be used as-is as a solver for all conflicts. * * an _Object_ argument should have keys that correspond to value types, i.e. 'object', 'array', 'function', 'string', 'number', 'boolean', 'null' or 'undefined'. The object values can be either strings or functions, which will be used as solver functions for the corresponding key value types. * @arg {string|module:bff/extend~conflictSolver} [defaultOnConflict] - Specifies a default solver, in the same manner as the onConflict argument. Can only be used if onConflict is an object. * @returns {Object} The extended object */ function extend(target, source, onConflict, defaultOnConflict) { if (RUNTIME_CHECKS) { if (typeof target !== 'object') { throw '&quot;target&quot; argument must be an object'; } if (typeof source !== 'object') { throw '&quot;source&quot; argument must be an object'; } if (arguments.length &gt; 2 &amp;&amp; [ 'object', 'function', 'string' ].indexOf(typeof onConflict) === -1) { throw '&quot;onConflict&quot; argument must be an string (' + Object.keys(SOLVERS).join(', ') + '), object or function'; } if (arguments.length &gt; 3) { if (typeof onConflict !== 'object') { throw 'There is no point in specifying a defaultOnConflict of onConflict is not an object'; } if ([ 'function', 'string' ].indexOf(typeof defaultOnConflict) === -1) { throw '&quot;defaultOnConflict&quot; argument must be a string (' + Object.keys(SOLVERS).join(', ') + '), or function'; } } } var isOnConflictObject = getType(onConflict) === 'object'; defaultOnConflict = getSolverFunction(isOnConflictObject ? defaultOnConflict : onConflict) || SOLVERS.crash; isOnConflictObject || (onConflict = {}); var solverFunctions = {}; TYPES.forEach(function (type) { solverFunctions[type] = getSolverFunction(onConflict[type]) || defaultOnConflict; }); for (var prop in source) { if (target.hasOwnProperty(prop)) { solverFunctions[getType(target[prop])](target, source, prop, onConflict, defaultOnConflict); } else { target[prop] = source[prop]; } } return target; } SOLVERS = { useTarget: function useTarget() { // Don't do nothin }, useSource: function useSource(target, source, prop) { target[prop] = source[prop]; }, crash: function crash(target, source, prop) { throw 'Extend target already has property ' + prop; }, merge: function merge(target, source, prop, onConflict, defaultOnConflict) { var sourceProp = source[prop]; var sourcePropType = getType(sourceProp); var targetProp = target[prop]; var targetPropType = getType(targetProp); if (targetPropType !== sourcePropType) { target[prop] = source[prop]; return; } switch (targetPropType) { case 'object': extend(targetProp, sourceProp, onConflict, defaultOnConflict); break; case 'array': target[prop] = targetProp.concat(sourceProp); break; case 'function': target[prop] = function () { targetProp.apply(this, arguments); sourceProp.apply(this, arguments); }; break; case 'string': case 'number': target[prop] = targetProp + sourceProp; break; case 'boolean': // Logical 'or' is kind of like the Boolean version of addition target[prop] = targetProp || sourceProp; break; default: // Don't to nothin for e.g. 'null' and 'undefined' break; } }, }; return extend; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.extend = moduleFactory(); } }()); × Search results Close "},"list.js.html":{"id":"list.js.html","title":"Source: list.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Source: list.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; /** * ## bff/list * Maintains a list of items. The idea is to stay as true as possible to the native Array interface, but to augment its usefulness by triggering events whenever the list is updated, as well as adding convenience functions for mutating the List in place. * * The exported List constructor can be used as-is, in which case a generic List will be created. This is a quite common use case. Alternatively, a List &quot;subclass&quot; constructor can be created by calling `List.withProperties(...)`. This second approach provides the possibility to add custom _calculated_ properties to the list. See {@link module:bff/list#withProperties} for more details. * * @exports bff/list */ function moduleFactory(extend, eventEmitter, Record) { var ADDED_EVENT = 'added'; var REPLACED_EVENT = 'replaced'; var REMOVED_EVENT = 'removed'; /** * @event module:bff/list#item:added * @arg {any} item - The item that was added to the List. * @arg {number} index - The position withing the List where the item was added. * @arg {module:bff/list} list - The List to which the item was added. */ var ITEM_ADDED_EVENT = 'item:added'; /** * @event module:bff/list#item:replaced * @arg {any} newItem - The item that was added to the List. * @arg {any} oldItem - The item that was removed from the List. * @arg {number} index - The position withing the List where the item was replaced. * @arg {module:bff/list} list - The List in which the item was replaced. */ var ITEM_REPLACED_EVENT = 'item:replaced'; /** * @event module:bff/list#item:removed * @arg {any} item - The item that was removed from the List. * @arg {number} index - The position withing the List where the item was removed. * @arg {module:bff/list} list - The List from which the item was removed. */ var ITEM_REMOVED_EVENT = 'item:removed'; /** * @event module:bff/list#change:length * @arg {number} newLength - The current length of the List. * @arg {number} oldLength - The previous length of the List. * @arg {module:bff/list} list - The List whose length has changed. */ var CHANGE_LENGTH_EVENT = 'change:length'; // &quot;Private event&quot; var PRECHANGE_LENGTH_EVENT = 'prechange:length'; var PRECHANGE_EVENT = 'prechange'; var CHANGE_EVENT = 'change'; /** * @callback module:bff/list~forEachCallback * @param {any} item - Current List item. * @param {number} index - Item position in List. * @param {module:bff/list} list - List being iterated over. */ /** * @callback module:bff/list~mapCallback * @param {any} item - Current List item. * @param {number} index - Item position in List. * @param {module:bff/list} list - List being iterated over. * @returns {any} Transformed object. */ /** * @callback module:bff/list~predicateCallback * @param {any} item - Current List item. * @param {number} index - Item position in List. * @param {module:bff/list} list - List being iterated over. * @returns {boolean} true if the item passes the test, false otherwise */ /** * @callback module:bff/list~reduceCallback * @param {any} previousItem - The value previously returned in the last invocation of the callback, or initialValue, if supplied. Usually an aggregate of previous items. * @param {any} item - Current List item being processed. * @param {number} index - Item position in List. * @param {module:bff/list} list - List being iterated over. * @returns {any} The aggregated value. */ /** * Compares _itemA_ and _itemB_ arguments according to some sorting criterion. Should return -1 if _itemA_ comes before _itemB_, 0 if _itemA_ is equal to _itemB_, 1 if _itemB_ comes before _itemA_. * @callback module:bff/list~compareFunction * @param {any} itemA - A list item. * @param {any} itemB - Another list item. * @returns {number}. */ var ITEM_EVENT_TOKEN_MATCHER = /item:/; function isEmitter(obj) { return !!(obj &amp;&amp; obj.addEventListener); } // Quack! function reemitItemEvent(self, item, strippedEventName, eventName) { self.listenTo(item, strippedEventName, function reemitItemEvent() { self.emitArgsAsArray(eventName, arguments); }); } function onItemAdded(self, item, index) { if (!isEmitter(item)) { self.emit(ITEM_ADDED_EVENT, item, index, self); return; } for (var eventName in self.__private.reEmittingEvents) { var strippedEventName = eventName.replace(ITEM_EVENT_TOKEN_MATCHER, ''); reemitItemEvent(self, item, strippedEventName, eventName); } item.emit(ADDED_EVENT, item, index, self); } function onItemRemoved(self, item, index) { if (!isEmitter(item)) { self.emit(ITEM_REMOVED_EVENT, item, index, self); return; } item.emit(REMOVED_EVENT, item, index, self); self.stopListening(item); } function onItemReplaced(self, newItem, oldItem, index) { if (newItem === oldItem) { return; } isEmitter(oldItem) ? oldItem.emit(REPLACED_EVENT, newItem, oldItem, index, self) : self.emit(ITEM_REPLACED_EVENT, newItem, oldItem, index, self); } function makeSetter(index) { // TODO: Investigate if this is really a good idea, performance wise return function setter(val) { this.splice(index, 1, val); }; } function makeGetter(index) { return function getter() { return this.__private.array[index]; }; } function delegate(funcName) { return function () { return this.__private.array[funcName].apply(this.__private.array, arguments); }; } function delegateCreator(funcName) { return function () { return new this.constructor(this.__private.array[funcName].apply(this.__private.array, arguments)); }; } function triggerPrechangeLengthEvent(self) { self.emit(PRECHANGE_EVENT, 'length', self.length, self); self.emit(PRECHANGE_LENGTH_EVENT, self.length, self); } function triggerChangeLengthEvent(self, prevLength) { if (self.length === prevLength) { return; } self.emit(CHANGE_EVENT, 'length', self.length, prevLength, self); self.emit(CHANGE_LENGTH_EVENT, self.length, prevLength, self); } /** * @alias module:bff/list */ var listFunctions = {}; /** * Add one or more items to the end of the List. Mirrors Array.push behavior. * @instance * @arg {...any} item - Each item argument will be pushed onto the List. * @emits module:bff/list#change:length * @emits module:bff/list#item:added * @returns {number} Updated List length */ listFunctions.push = function () { var nItems = arguments.length; if (nItems === 0) { return this.length; } var prevLength = this.length; triggerPrechangeLengthEvent(this); this.__private.array.push.apply(this.__private.array, arguments); triggerChangeLengthEvent(this, prevLength); for (var i = 0; i &lt; nItems; ++i) { onItemAdded(this, this[prevLength + i], prevLength + i); } return this.length; }; /** * Add one or more items to the beginning of the List. Mirrors Array.unshift behavior. * @instance * @arg {...any} item - Each item argument will be pushed onto the List. * @emits module:bff/list#change:length * @emits module:bff/list#item:added * @returns {Number} Updated List length */ listFunctions.unshift = function () { var nItems = arguments.length; if (nItems === 0) { return this.length; } var prevLength = this.length; triggerPrechangeLengthEvent(this); this.__private.array.unshift.apply(this.__private.array, arguments); triggerChangeLengthEvent(this, prevLength); for (var i = 0; i &lt; nItems; ++i) { onItemAdded(this, this[i], i); } return this.length; }; /** * Remove and return one item from the end of the List. Mirrors Array.pop behavior. * @instance * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {any} Removed item */ listFunctions.pop = function () { if (this.length === 0) { return; } var prevLength = this.length; triggerPrechangeLengthEvent(this); var poppedItem = this.__private.array.pop.apply(this.__private.array, arguments); triggerChangeLengthEvent(this, prevLength); onItemRemoved(this, poppedItem, this.length); return poppedItem; }; /** * Remove and return one item from the beginning of the List. Mirrors Array.shift behavior. * @instance * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {any} Removed item */ listFunctions.shift = function () { if (this.length === 0) { return; } var prevLength = this.length; triggerPrechangeLengthEvent(this); var shiftedItem = this.__private.array.shift.apply(this.__private.array, arguments); triggerChangeLengthEvent(this, prevLength); onItemRemoved(this, shiftedItem, 0); return shiftedItem; }; /** * Changes the content of the List by removing existing items and/or adding new items. Mirrors Array.splice behavior. * @instance * @arg {number} start - Index at which to start changing the array. If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many items from the end. * @arg {number} nItemsToRemove - An integer indicating the number of old array items to remove. If nItemsToRemove is greater than the number of items left in the array starting at start, then all of the items through the end of the array will be deleted. * @arg {...any} [itemToAdd] - Item that will be added to the array, starting at the index specified in the first argument. * @emits module:bff/list#change:length * @emits module:bff/list#item:added * @emits module:bff/list#item:replaced * @emits module:bff/list#item:removed * @returns {any[]} Array of removed items */ listFunctions.splice = function (start, nItemsToRemove) { if (RUNTIME_CHECKS) { if (arguments.length &lt; 2) { throw '&quot;start&quot; and &quot;nItemsToRemove&quot; arguments are mandatory'; } if (typeof start !== 'number') { throw '&quot;start&quot; argument must be a number'; } if (typeof nItemsToRemove !== 'number') { throw '&quot;nItemsToRemove&quot; argument must be a number'; } } var i; var oldLength = this.length; start &lt; 0 &amp;&amp; (start = oldLength + start); nItemsToRemove = Math.min(nItemsToRemove, oldLength - start); var nItemsToAdd = arguments.length - 2; var nItemsToReplace = Math.min(nItemsToAdd, nItemsToRemove); var nItemsAffected = Math.max(nItemsToAdd, nItemsToRemove); var prevLength = this.length; triggerPrechangeLengthEvent(this); var deletedItems = this.__private.array.splice.apply(this.__private.array, arguments); triggerChangeLengthEvent(this, prevLength); for (i = 0; i &lt; nItemsAffected; ++i) { i &lt; nItemsToAdd &amp;&amp; onItemAdded(this, this[start + i], start + i); i &lt; nItemsToReplace &amp;&amp; onItemReplaced(this, this[start + i], deletedItems[i], start + i); i &lt; nItemsToRemove &amp;&amp; onItemRemoved(this, deletedItems[i], start + i); } return deletedItems; }; [ /** * Executes the given function once per List item. Mirrors Array.forEach behavior. * @func forEach * @instance * @arg {module:bff/list~forEachCallback} callback - The function that will be called once per List item. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. */ 'forEach', /** * Mirrors Array.every behavior. * @func every * @instance * @arg {module:bff/list~predicateCallback} predicate - Executed once per List item. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. * @returns {boolean} true if all items passes the predicate test, false otherwise. */ 'every', /** * Mirrors Array.some behavior. * @func some * @instance * @arg {module:bff/list~predicateCallback} predicate - Executed once per List item. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. * @returns {boolean} true if at least one item passes the predicate test, false otherwise. */ 'some', /** * Mirrors Array.indexOf behavior. * @func indexOf * @instance * @arg {any} searchItem - The item to locate within the List. * @arg {number} [fromIndex] - The index to start the search at. If the index is greater than or equal to the List's length, -1 is returned, which means the List will not be searched. If the provided index value is a negative number, it is taken as the offset from the end of the List. * @returns {number} The first index at which a given item can be found in the List, or -1 if it is not present. */ 'indexOf', /** * @func lastIndexOf * @instance * @arg {any} searchItem - The item to locate within the List. * @arg {number} [fromIndex] - The index at which to start searching backwards. Defaults to the List's length minus one, i.e. the whole List will be searched. If the index is greater than or equal to the length of the List, the whole List will be searched. If negative, it is taken as the offset from the end of the List. Mirrors Array.lastIndexOf behavior. * @returns {number} The last index at which a given item can be found in the List, or -1 if it is not present. */ 'lastIndexOf', /** * @func join * @instance * @arg {string} [separator] - Specifies a string to separate each item of the List. If omitted, the List items are separated with a comma. Mirrors Array.join behavior. * @returns {string} The stringified List items, joined by the 'separator' string argument. */ 'join', /** * Applies a function against an accumulator and each value of the List (from left-to-right) to reduce it to a single value. Mirrors Array.reduce behavior. * @func reduce * @instance * @arg {module:bff/list~reduceCallback} callback - The function that will be called once per List item. * @arg {any} initialValue - Value to use as the first argument to the first call of the callback. * @returns {any} Aggregated value */ 'reduce', /** * Applies a function against an accumulator and each value of the List (from right-to-left) to reduce it to a single value. Mirrors Array.reduceRight behavior. * @func reduceRight * @instance * @arg {module:bff/list~reduceCallback} callback - The function that will be called once per List item. * @arg {any} initialValue - Value to use as the first argument to the first call of the callback. * @returns {any} Aggregated value */ 'reduceRight' ].forEach(function (funcName) { listFunctions[funcName] = Array.prototype[funcName]; }); [ /** * Sorts the items of the List in place. The sort is not necessarily stable. The default sort order is according to string Unicode code points, unless a custom comparator finction is provided. Mirrors the behavior of Array.sort. No events are emitted by this operation. * @func sort * @instance * @arg {module:bff/list~compareFunction} [comparator] - A function that specifies the ordering of two arbitrary List items. Called multiple times in order to produce a total ordering of the items. * @returns {List} The sorted list. */ 'sort', /** * Reverses the List in place. Mirros the behavior of Array.reverse. No events are emitted by this operation. * @func reverse * @instance */ 'reverse' ].forEach(function (funcName) { listFunctions[funcName] = delegate(funcName); }); [ /** * Creates a new List with all items that pass the test implemented by the predicate function test. The original list is unchanged. Mirrors the behavior of Array.filter. * @func filter * @instance * @arg {module:bff/list~predicateCallback} predicate - Executed once per List item. * @returns {List} The new List. */ 'filter', /** * Creates a new List from the range of current items specified by the begin and end arguments. Mirrors the behavior of Array.slice. * @func slice * @instance * @arg {number} [begin] Index that specifies the beginning of the range. Inclusive. A negative index will * be relative to the end of the List instead of the beginning. * @arg {number} [end] Index that specifies the end of the range. Exclusive. A negative index will * be relative to the end of the List instead of the beginning. * @returns {List} The new List. */ 'slice', /** * Creates a new List with the results of calling a provided callback function on every element in the List. Mirrors the behavior of Array.map. * @func map * @instance * @arg {module:bff/module~mapCallback} callback - Executed once per List item. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. * @returns {List} The new List. */ 'map' ].forEach(function (funcName) { listFunctions[funcName] = delegateCreator(funcName); }); /** * Returns a new List comprised of the List on which it is called joined with the List(s), Array(s) and/or value(s) provided as arguments. Mirrors the behavior of Array.concat. * @instance * @arg {...any} value - A List, Array or value that will be concatenated with the original List. Lists and Arrays will be deconstructed and each item added to the new List. * @returns {List} The new List. */ listFunctions.concat = function () { for (var i = 0, n = arguments.length; i &lt; n; ++i) { var argument = arguments[i]; if (!(argument instanceof Array) &amp;&amp; argument.length !== undefined) { arguments[i] = argument.toArray(); } } return new this.constructor(this.__private.array.concat.apply(this.__private.array, arguments)); }; /** * Mutates the List by removing all items that does not pass the predicate function test. * @instance * @arg {module:bff/list~predicateCallback} predicate - Called once per List item to determine whether the item should be removed. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing predicate callback. * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {List} The filtered List. */ listFunctions.filterMut = function (predicate, thisArg) { if (RUNTIME_CHECKS) { if (typeof predicate !== 'function') { throw '&quot;predicate&quot; argument must be a function'; } } var removeCount = 0; for (var i = this.length - 1; i &gt;= -1; --i) { if (i &gt; -1 &amp;&amp; !predicate.call(thisArg, this[i], i, this)) { removeCount++; } else if (removeCount) { this.splice(i + 1, removeCount); removeCount = 0; } } return this; }; /** * Mutates the List by removing all occurances of the provided item. * @instance * @arg {any} item - The item to remove from the list. * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {List} The List, without any occurances of 'item'. */ listFunctions.remove = function (item) { return this.filterMut(function (listItem) { return item !== listItem; }); }; /** * Mutates the List by removing all items. * @instance * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {List} The List, now empty. */ listFunctions.clear = function () { return this.splice(0, this.length); }; /** * Mutates the List by adding the items comprising the provided List or Array to the end of the List. * @instance * @arg {module:bff/list|Array} items - The items that will be appended to the List. * @emits module:bff/list#change:length * @emits module:bff/list#item:added * @returns {List} The List, with new items appended. */ listFunctions.pushAll = function (items) { if (RUNTIME_CHECKS &amp;&amp; (!items || items.length === undefined)) { throw '&quot;items&quot; argument must have a length property'; } items.length &amp;&amp; this.push.apply(this, items); return this.length; }; /** * Mutates the List by removing all elements outside of range specified by the begin and end arguments. * @instance * @arg {number} [begin] Index that specifies the beginning of the range. Inclusive. A negative index will be relative to the end of the List instead of the beginning. * @arg {number} [end] Index that specifies the end of the range. Exclusive. A negative index will be relative to the end of the List instead of the beginning. * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {List} The List, sans the items outside of the specified range. */ listFunctions.sliceMut = function (begin, end) { if (RUNTIME_CHECKS) { if (arguments.length &lt; 2) { throw '&quot;begin&quot; and &quot;end&quot; arguments are mandatory'; } if (typeof begin !== 'number') { throw '&quot;begin&quot; argument must be a number'; } if (typeof end !== 'number') { throw '&quot;end&quot; argument must be a number'; } } var length = this.length; end = (typeof end !== 'undefined') ? end : length; // Handle negative value for &quot;begin&quot; var start = begin || 0; start = (start &gt;= 0) ? start : Math.max(0, length + start); // Handle negative value for &quot;end&quot; var upTo = ((typeof end === 'number') ? Math.min(end, length) : length) - 1; end &lt; 0 &amp;&amp; (upTo = length + end); // Actual expected size of the slice var size = upTo - start; if (size !== length) { this.splice(0, start); this.splice(upTo, length - upTo); } return this; }; /** * Replaces all items in the List with new items, generated by the callback function. * @instance * @arg {module:bff/module~mapCallback} callback - Executed once per List item to produce new items. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. * @emits module:bff/list#item:replaced * @returns {List} The List, with all items updated. */ listFunctions.mapMut = function (callback, thisArg) { if (RUNTIME_CHECKS &amp;&amp; typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; } for (var i = 0, length = this.length; i &lt; length; ++i) { this[i] = callback.call(thisArg, this[i], i, this); } return this; }; /** * Returns the first item in the List that passes the predicate function test, or undefined if no item passes. * @instance * @arg {module:bff/list~predicateCallback} predicate - Called once per List item to in order to find a matching item. * @returns {any|undefined} The matching item, if any. */ listFunctions.find = function (predicate, thisArg) { if (RUNTIME_CHECKS &amp;&amp; typeof predicate !== 'function') { throw '&quot;predicate&quot; argument must be a function'; } for (var i = 0, length = this.length; i &lt; length; ++i) { if (predicate.call(thisArg, this[i], i, this)) { return this[i]; } } }; /** * Returns the index of the first item in the List that passes the predicate function test, or -1 if no item passes. * @instance * @arg {module:bff/list~predicateCallback} predicate - Called once per List item to in order to find a matching item. * @returns {number} The position of the matching item, or -1 if none matches. */ listFunctions.findIndex = function (predicate, thisArg) { if (RUNTIME_CHECKS &amp;&amp; typeof predicate !== 'function') { throw '&quot;predicate&quot; argument must be a function'; } for (var i = 0, length = this.length; i &lt; length; ++i) { if (predicate.call(thisArg, this[i], i, this)) { return i; } } return -1; }; /** * Returns whether the provided item is part of the List. * @instance * @arg {any} item * @arg {number} [fromIndex] - The index to start the search at. If the index is greater than or equal to the List's length, -1 is returned, which means the List will not be searched. If the provided index value is a negative number, it is taken as the offset from the end of the List. * @returns {boolean} True if the item is part of the List, false otherwise. */ listFunctions.includes = function (item, fromIndex) { if (RUNTIME_CHECKS &amp;&amp; arguments.length &gt; 1 &amp;&amp; typeof fromIndex !== 'number') { throw '&quot;fromIndex&quot; number must be a number'; } fromIndex = fromIndex || 0; var index = this.__private.array.indexOf(item); return index !== -1 &amp;&amp; index &gt;= fromIndex; }; /** * Returns an newly created Array, containing all the items of the List. List properties are not copied to the Array object. The items are copied shallowly. * @instance * @returns {Array} */ listFunctions.toArray = function () { return this.__private.array.slice(); }; /** * Returns a newly created Array representation of the List, containing deep copies of all the List's items, but not its properties. * @instance * @returns {Array} */ listFunctions.toJSON = function () { var jsonObj = new Array(this.length); for (var i = 0, n = jsonObj.length; i &lt; n; ++i) { var item = this[i]; jsonObj[i] = item instanceof Object ? (item.toJSON ? item.toJSON() : JSON.parse(JSON.stringify(item))) : item; } return jsonObj; }; /** * Returns a newly created Object containing the List's deep copied properties. * @instance * @returns {Object} */ listFunctions.propertiesToJSON = function () { return Record.prototype.toJSON.call(this); }; /** * Augmented version of {@link module:bff/event-emitter#addEventListener} that provides the option to listen to events emitted from any item in the List. To add a listener to an item event, prepend the event name with 'item:'. For instance, to listen for the 'change' event on all the list items (even ones added after the listener was created), add a listener for the 'item:change' event. * @instance * @arg {string} - Identifier string for the event. */ listFunctions.addEventListener = function (eventName) { if (RUNTIME_CHECKS &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (!ITEM_EVENT_TOKEN_MATCHER.test(eventName) || this.__private.reEmittingEvents[eventName]) { return; } this.__private.reEmittingEvents[eventName] = true; var strippedEventName = eventName.replace(ITEM_EVENT_TOKEN_MATCHER, ''); for (var i = 0, n = this.length; i &lt; n; ++i) { var item = this[i]; isEmitter(item) &amp;&amp; reemitItemEvent(this, item, strippedEventName, eventName); } }; /** * Augmented version of {@link module:bff/event-emitter#addEventListener} that provides functionality for removing &quot;item&quot; event listeners, e.g. for stop listening to events like &quot;items:change&quot;. * @instance * @arg {string} - Identifier string for the event. */ listFunctions.removeEventListener = function (eventName) { if (RUNTIME_CHECKS &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (!ITEM_EVENT_TOKEN_MATCHER.test(eventName)) { return; } // Check if we still need to re-emit this event var listeners = this.__private.listeners[eventName]; if (listeners &amp;&amp; listeners.length) { return; } delete this.__private.reEmittingEvents[eventName]; var strippedEventName = eventName.replace(ITEM_EVENT_TOKEN_MATCHER, ''); this.stopListening(undefined, strippedEventName); }; extend(listFunctions, eventEmitter, { 'function': 'merge' }); /** * @instance * @returns {string} A human readable string representation of the List. */ listFunctions.toString = function () { return JSON.stringify(this, undefined, 2); }; function withProperties(schema) { for (var propName in schema) { var propertySchema = schema[propName]; if (RUNTIME_CHECKS &amp;&amp; !propertySchema.getter) { throw 'List property ' + propName + ' must have a custom getter function'; } if (RUNTIME_CHECKS &amp;&amp; propertySchema.setter) { throw 'List property ' + propName + ' may not have a setter'; } propertySchema.setter = false; } extend(schema, { length: { getter: function () { return this.__private.array.length; }, setter: false, }, first: { getter: function () { return this[0]; }, setter: false, }, last: { getter: function () { return this[this.length - 1]; }, setter: false, } }); var RecordSubclass = Record.withProperties(schema, true); function List(items) { if (RUNTIME_CHECKS &amp;&amp; arguments.length &gt; 0 &amp;&amp; (!items || items.length === undefined)) { throw '&quot;items&quot; argument must have a length property'; } this.__private || Object.defineProperty(this, '__private', { writable: true, value: {}, }); this.__private.array = []; this.__private.reEmittingEvents = {}; this.listenTo(this, CHANGE_LENGTH_EVENT, function (length, prevLength) { var diff = length - prevLength; var i; if (diff &gt; 0) { for (i = prevLength; i &lt; length; ++i) { Object.defineProperty(this, i, { enumerable: true, configurable: true, get: makeGetter(i), set: makeSetter(i), }); } } else { for (i = length; i &lt; prevLength; ++i) { delete this[i]; } } }); // We don't want to send any arguments to the record constructor, // none of the properties we added has any setters! RecordSubclass.call(this); items = items || []; items.length &amp;&amp; this.pushAll(items); } List.prototype = Object.create(RecordSubclass.prototype); List.prototype.constructor = List; extend(List.prototype, listFunctions); return List; } /** * Creates a new List, with an optional list or array of initial items. * @constructor * @alias module:bff/list * @mixes bff/event-emitter * @mixes bff/event-listener * @arg {(Array|List)} [items] - Items that will be added to the List on creation. */ var List = withProperties({}); /** * Creates a new List constructor function, that will create List instances with the property schema * provided to this function * @func * @static * @arg {Object} schema - An object describing the properties that will be part of all new instances created by the returned constructor function. The property descriptions should be on the same format at the schema specified for {@link module:bff/record#withProperties}, with the only exception that setters are not allowed. * @returns {function} New constructor function based on the provided schema. */ List.withProperties = withProperties; return List; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([ './extend', './event-emitter', './record' ], moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(require('./extend'), require('./event-emitter'), require('./record')); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.List = moduleFactory(bff.extend, bff.eventEmitter, bff.Record); } }()); × Search results Close "},"patch-dom.js.html":{"id":"patch-dom.js.html","title":"Source: patch-dom.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Source: patch-dom.js /* global define */ (function () { 'use strict'; /** * ## bff/patch-dom * @module bff/patch-dom */ function moduleFactory() { function makeLevMat(xSize, ySize) { var i, levMat = new Array(xSize + 1); for (i = 0; i &lt;= xSize; ++i) { levMat[i] = new Array(ySize + 1); levMat[i][0] = i; } for (i = 0; i &lt;= ySize; ++i) { levMat[0][i] = i; } return levMat; } var preallocLevMatSizeX = 63; var preallocLevMatSizeY = 63; var preallocLevMat = makeLevMat(preallocLevMatSizeX, preallocLevMatSizeY); function areOfSameType(target, source) { if (!source) { return false; } if (target.nodeName === source.nodeName) { return true; } return false; } function namedNodeMapToObject(namedNodeMap) { var obj = {}; for (var i = 0, n = namedNodeMap.length; i &lt; n; ++i) { var node = namedNodeMap[i]; obj[node.name] = node.value; } return obj; } function patchElementNode(target, source) { // Ref: http://quirksmode.org/dom/core/#attributes var targetAttrObj = namedNodeMapToObject(target.attributes); var sourceAttrArr = source.attributes; var i, n, sourceAttr, targetAttr, attrName; // Special cases if (target.nodeName === 'INPUT') { target.value = source.value || ''; } if (source.checked !== undefined) { target.checked = source.checked; } if (source.selected !== undefined) { target.selected = source.selected; } for (i = 0, n = sourceAttrArr.length; i &lt; n; ++i) { sourceAttr = sourceAttrArr[i]; attrName = sourceAttr.name; targetAttr = targetAttrObj[attrName]; delete targetAttrObj[sourceAttr.name]; if (targetAttr &amp;&amp; targetAttr.value === sourceAttr.value) { continue; } target.setAttribute(attrName, sourceAttr.value); } for (attrName in targetAttrObj) { target.removeAttribute(attrName); } } function patchTextNode(target, source) { var sourceValue = source.nodeValue; if (target.nodeValue === sourceValue) { return; } target.nodeValue = sourceValue; } function patchNode(target, source) { switch (target.nodeType) { case Node.ELEMENT_NODE: patchElementNode(target, source); break; case Node.TEXT_NODE: patchTextNode(target, source); break; } } function shouldIgnoreNode(node) { return !!node.hasAttribute &amp;&amp; node.hasAttribute('patch-ignore'); } function patchRecursive(target, source, ignoreSubtreeOf) { var targetParent = target.parentNode; var childrenToPatch = []; // Patch the current node if (areOfSameType(target, source)) { patchNode(target, source); } else { if (source) { targetParent.replaceChild(source, target); } else { targetParent.removeChild(target); } return; } if (ignoreSubtreeOf &amp;&amp; Array.prototype.indexOf.call(ignoreSubtreeOf, target) !== -1) { return; } // Diff subtree using Levenshtein distance algorithm var targetChildren = target.childNodes; var sourceChildren = source.childNodes; var i, n, targetPos, sourcePos, targetChild, sourceChild; var nTargetChildren = targetChildren.length; var nSourceChildren = sourceChildren.length; var nLeadingSameTypeChildren = 0; var nIgnoredTargetChildren = 0; var nTargetChildrenToIgnore = 0; var allChildrenMatchSoFar = true; for (i = 0; i &lt; nTargetChildren; ++i) { if (shouldIgnoreNode(targetChildren[i])) { nTargetChildrenToIgnore++; } else if (allChildrenMatchSoFar) { if (areOfSameType(targetChildren[i + nTargetChildrenToIgnore], sourceChildren[i])) { childrenToPatch.push(targetChildren[i + nTargetChildrenToIgnore]); childrenToPatch.push(sourceChildren[i]); nLeadingSameTypeChildren++; } else { allChildrenMatchSoFar = false; } } } if (nTargetChildren - nTargetChildrenToIgnore === 0 &amp;&amp; nSourceChildren === 0) { return; } var levMatSizeX = nTargetChildren - nLeadingSameTypeChildren; var levMatSizeY = nSourceChildren - nLeadingSameTypeChildren; var levMat; if (preallocLevMatSizeX &lt; levMatSizeX || preallocLevMatSizeY &lt; levMatSizeY) { // The preallocated matrix is too small. if (preallocLevMatSizeX &lt;= levMatSizeX &amp;&amp; preallocLevMatSizeY &lt;= levMatSizeY) { // The needed matrix is bigger or equal to the preallocated one i all dimensions, so let's grow the // preallocated one. preallocLevMatSizeX = levMatSizeX; preallocLevMatSizeY = levMatSizeY; preallocLevMat = makeLevMat(preallocLevMatSizeX, preallocLevMatSizeY); levMat = preallocLevMat; } else { // The needed matrix is larger than the preallocated one in some, but not all dimensions. This // should be quite an edge case, so just use a temporary matrix for this operation. levMat = makeLevMat(levMatSizeX, levMatSizeY); } } else { // The needed matrix fits inside the preallocated one, so just use that one. This should be the most // common case. levMat = preallocLevMat; } for (targetPos = 1; targetPos + nIgnoredTargetChildren &lt;= nTargetChildren - nLeadingSameTypeChildren; targetPos++) { targetChild = targetChildren[targetPos + nIgnoredTargetChildren + nLeadingSameTypeChildren - 1]; if (shouldIgnoreNode(targetChild)) { nIgnoredTargetChildren++; targetPos--; continue; } for (sourcePos = 1; sourcePos &lt;= nSourceChildren - nLeadingSameTypeChildren; ++sourcePos) { if (areOfSameType(targetChild, sourceChildren[sourcePos + nLeadingSameTypeChildren - 1])) { levMat[targetPos][sourcePos] = levMat[targetPos - 1][sourcePos - 1]; } else { levMat[targetPos][sourcePos] = 1 + Math.min( levMat[targetPos - 1][sourcePos - 1], levMat[targetPos][sourcePos - 1], levMat[targetPos - 1][sourcePos]); } } } targetPos = nTargetChildren - nLeadingSameTypeChildren - nTargetChildrenToIgnore; sourcePos = nSourceChildren - nLeadingSameTypeChildren; while (targetPos &gt; 0 || sourcePos &gt; 0) { targetChild = targetChildren[targetPos + nLeadingSameTypeChildren + nTargetChildrenToIgnore - 1]; if (shouldIgnoreNode(targetChild)) { nTargetChildrenToIgnore--; continue; } var substitution = targetPos &gt; 0 &amp;&amp; sourcePos &gt; 0 ? levMat[targetPos - 1][sourcePos - 1] : Infinity; var insertion = sourcePos &gt; 0 ? levMat[targetPos][sourcePos - 1] : Infinity; var deletion = targetPos &gt; 0 ? levMat[targetPos - 1][sourcePos] : Infinity; sourceChild = sourceChildren[sourcePos + nLeadingSameTypeChildren - 1]; if (substitution &lt;= insertion &amp;&amp; substitution &lt;= deletion) { if (substitution &lt; levMat[targetPos][sourcePos]) { // Substitute target.replaceChild(sourceChild, targetChild); } else { // Add to patch list childrenToPatch.push(targetChild); childrenToPatch.push(sourceChild); } targetPos--; sourcePos--; } else if (insertion &lt;= deletion) { // Insert target.insertBefore(sourceChild, targetChild.nextSibling); sourcePos--; } else { // Delete target.removeChild(targetChild); targetPos--; } } for (i = 0, n = childrenToPatch.length; i &lt; n; i += 2) { patchRecursive(childrenToPatch[i], childrenToPatch[i + 1], ignoreSubtreeOf); } } /** * Patches the target element and its child elements such that it will be identical to the source element and its child structure. It achieves this by recursively _patching_, _removing_ or _adding_ elements in the target element hierarchy. The overall logic of the algorithm goes as follows: * * If the target and source elements have differing node type types (e.g. a `&lt;div&gt;` and a `&lt;span&gt;` tag) the target element is replaced by the source element. * * Otherwise, if the target and source elements are of the same type (e.g. two `&lt;div&gt;` tags), the attributes of the target element will be replaced by those of the target element. Then the target and source elements' children lists are compared using a version of the Levenshtein algorithm. This results in the children of the target element being either patched (by calling `patchDom` recursively) or removed. Child elements only present in the source child list will also be added to the target child list at their respective positions. * * If any encountered target elements has a `patch-ignore` attribute, that node and its children will not be patched. * * @alias module:bff/patch-dom * @arg {HTMLElement} target - The element (hierarchy) to be patched. Will be identical to the source element (hierarchy) after the function call completes. * @arg {HTMLElement} source - The element (hierarchy) that the target (hierarchy) will be transformed into. * @arg {Object} [options] - Options that will be recursively passed down to all patchDom calls. Currently only one option is implemented: * * _ignoreSubtreeOf_: A CSS selector string that identifies any elements, whose subtrees will not be patched. */ function patchDom(target, source, options) { options = options || {}; if (RUNTIME_CHECKS) { if (!(target instanceof HTMLElement)) { throw '&quot;target&quot; argument must be an HTMLElement'; } if (!(source instanceof HTMLElement)) { throw '&quot;source&quot; argument must be an HTMLElement'; } if (arguments.length &gt; 2 &amp;&amp; typeof options !== 'object') { throw '&quot;options&quot; argument must be an object'; } if ('ignoreSubtreeOf' in options &amp;&amp; typeof options.ignoreSubtreeOf !== 'string') { throw 'ignoreSubtreeOf option must be a valid CSS selector string'; } } var ignoreSubtreeOf = options.ignoreSubtreeOf &amp;&amp; target.querySelectorAll(options.ignoreSubtreeOf); patchRecursive(target, source, ignoreSubtreeOf); return target; } return patchDom; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.patchDom = moduleFactory(); } }()); × Search results Close "},"record.js.html":{"id":"record.js.html","title":"Source: record.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Source: record.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; /** * ## bff/record * A [Record](https://en.wikipedia.org/wiki/Record_(computer_science) is the basic entity of the data layer. In difference to regular JS objects, it has a predefined set of properties. The properties are specified by &quot;subclassing&quot; the abstract Record constructor by calling `Record.withProperties(...)` and providing a properties schema. For more details, see {@link module:bff/record#withProperties}. * * The major advantages of using a predefined (i.e. known and finite) set of properties are: * * Each property gets a custom setter, that emits a change event whenever the property value changes. The setter can also do types checks on the assigned value (which it does in dev. mode). * * The record instances can be locked using Object.preventExtensions, with the nice effect that trying to assign a value to an undeclared property will throw an error. * * @exports bff/record */ function moduleFactory(extend, eventEmitter, eventListener) { var PRECHANGE_EVENT = 'prechange'; var CHANGE_EVENT = 'change'; function validateInput(val, propName, propSchema) { var type = typeof val; if ('type' in propSchema &amp;&amp; propSchema.type.indexOf(type) === -1) { throw 'Property ' + propName + ' is of type ' + propSchema.type + ' and can not be assigned a value of type ' + type; } } function makeSetter(propName, propSchema) { var MY_PRECHANGE_EVENT = PRECHANGE_EVENT + ':' + propName; var MY_CHANGE_EVENT = CHANGE_EVENT + ':' + propName; // TODO: make two different setter functions (in outer scope) and select (+bind) // one of the depending of whether the propery has any dependers return function setter(val) { // If there is a custom setter, use it to transform the value propSchema.setter &amp;&amp; (val = propSchema.setter.call(this, val)); var oldVal = this[propName]; this.emit(PRECHANGE_EVENT, propName, oldVal, this); this.emit(MY_PRECHANGE_EVENT, oldVal, this); this.__private.values[propName] = val; // If the value change did not affect the public value, we don't trigger any change events if (this[propName] === oldVal) { return; } var newVal = this[propName]; this.emit(CHANGE_EVENT, propName, newVal, oldVal, this); this.emit(MY_CHANGE_EVENT, newVal, oldVal, this); // Input validation, after setters and getters has been applied RUNTIME_CHECKS &amp;&amp; validateInput(newVal, propName, propSchema); }; } function makeGetter(propName, propSchema) { return propSchema.getter ? function getter() { return propSchema.getter.call(this, this.__private.values[propName]); } : function getter() { return this.__private.values[propName]; }; } /** * Creates a new Record (subclass) with an optional set of initial values. * @alias module:bff/record * @constructor * @mixes bff/event-emitter * @mixes bff/event-listener * @arg {Object|module:bff/record} [values] - An object containing initial values for the Record to be created. */ function Record(values) { if (RUNTIME_CHECKS &amp;&amp; values !== undefined &amp;&amp; typeof values !== 'object') { throw '&quot;values&quot; argument must be an object'; } if (!this.__private) { throw 'Record is an abstract class, meant to be &quot;subclassed&quot; using Record.withProperties(schema)'; } this.__private.values = {}; this.__private.previousValues = {}; var schema = this.__private.schema; var propsUnion = {}; for (var propName in schema) { propsUnion[propName] = schema[propName].defaultValue; } for (propName in values) { if (RUNTIME_CHECKS &amp;&amp; !schema.hasOwnProperty(propName)) { throw 'Cannot assign undeclared property ' + propName; } propsUnion[propName] = values[propName]; } // Silently assign initial values for (propName in propsUnion) { var val = propsUnion[propName]; schema[propName].setter &amp;&amp; (val = schema[propName].setter.call(this, val)); this.__private.values[propName] = val; RUNTIME_CHECKS &amp;&amp; validateInput(this[propName], propName, schema[propName]); } var onPreChangeEvent = function (propName) { var oldVal = this.__private.previousValues[propName] = this[propName]; this.emit(PRECHANGE_EVENT, propName, oldVal, this); this.emit(PRECHANGE_EVENT + ':' + propName, oldVal, this); }; var onChangeEvent = function (propName) { var oldVal = this.__private.previousValues[propName]; var newVal = this[propName]; // If the value change did not affect the public value, we don't trigger any change events if (newVal === oldVal) { return; } this.emit(CHANGE_EVENT, propName, newVal, oldVal, this); this.emit(CHANGE_EVENT + ':' + propName, newVal, oldVal, this); }; for (propName in schema) { var propSchema = schema[propName]; if (!propSchema.dependencies) { continue; } for (var i = 0; i &lt; propSchema.dependencies.length; ++i) { var dependencyPropName = propSchema.dependencies[i]; this.listenTo(this, PRECHANGE_EVENT + ':' + dependencyPropName, onPreChangeEvent.bind(this, propName)); this.listenTo(this, CHANGE_EVENT + ':' + dependencyPropName, onChangeEvent.bind(this, propName)); } } } /** * Returns a newly created Object containing the Records's deep copied properties. The fact that this function returns an Object and not a strin is a bit misleading, but this naming convension is used for conformity reasons, see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON_behavior} * @returns {Object} */ Record.prototype.toJSON = function () { var jsonObj = {}; for (var propName in this.__private.values) { var val = this[propName]; jsonObj[propName] = val instanceof Object ? (val.toJSON ? val.toJSON() : JSON.parse(JSON.stringify(val))) : val; } return jsonObj; }; /** * @returns {string} A human readable string representation of the Record. */ Record.prototype.toString = function () { return JSON.stringify(this, undefined, 2); }; extend(Record.prototype, eventEmitter); extend(Record.prototype, eventListener); /** * Creates a new Record constructor function, that will create Record instances with the property schema provided to this function. The various aspects of the property schema are described in detail below, but let's start with an example. * ```javascript * var Person = Record.withProperties({ * firstName: 'string', * lastName: 'string', * fullName: { * setter: false, * getter: function () { return this.firstName + ' ' + this.lastName; }, * dependencies: [ 'firstName', 'lastName' ], * }, * age: { * type: [ 'number', undefined ], * defaultValue: 0, * }, * someData: {}, * }) * ``` * Here we see a schema with five properties. The first two (_firstName_ and _lastName_) use a shorthand syntax to declare string properties. The _fullName_ property is a calculated property that depends on _firstName_ and _lastName_. The _age_ property is either a number or undefined (properties can't be undefined by default), with a default value of 0. Finally, the _someData_ property can be of any type. * @func * @static * @arg {Object} schema - An object describing the properties that will be part of all new instances created by the returned constructor function. Each key/value pair describes a single property. Property descriptor objects can have the following properties: * * _type_: A string or array of strings specifying the type of the property. If omitted, no type checking will be performed, otherwise types are checked by applying the typeof operator to the assigned value and then checking to see if the returned type string is part of the schema types. * * _defaultValue_: An initial value that will be assigned to all new instances of this property upon creation. * * _setter_: A function that will be called to transform the assigned value before it is stored on the property. Shouldn't have any side effects, as it might be called internally to determine when events should be triggered. * * _getter_: A function that will be run to transform the read value before it is returned. Shouldn't have any side effects, as it might be called internally to determine when events should be triggered. * * All schema descriptor properties are optional. An empty schema descriptor can be replaced with any falsy value for the same effect, which means that: * `someData: {}`, `someData: undefined`, `someData: null` and `someData: false` all declares a property named someData, which can hold any type of data. * * There is also a shorthand syntax for specifying typed properties, because it is such a common use case, e.g.: * `aProp: 'string'` is equal to `aProp: { type: 'string' }` and e.g. * `aProp: [ 'string', 'undefined' ]` is equal to `aProp: { type: [ 'string', 'undefined' ] }` * * @returns {function} New constructor function based on the provided schema. */ Record.withProperties = function (schema, dontPreventExtensions) { if (RUNTIME_CHECKS) { if (typeof schema !== 'object') { throw '&quot;schema&quot; argument must be an object'; } if (arguments.length &gt; 1 &amp;&amp; typeof dontPreventExtensions !== 'boolean') { throw '&quot;dontPreventExtensions&quot; must be a boolean value'; } } var RecordSubclass = function RecordSubclass(values) { this.__private || Object.defineProperty(this, '__private', { writable: true, value: {}, }); this.__private.schema = schema; Record.call(this, values); dontPreventExtensions || Object.preventExtensions(this); }; RecordSubclass.prototype = Object.create(Record.prototype); RecordSubclass.prototype.constructor = RecordSubclass; var props = {}; for (var propName in schema) { var propSchema = schema[propName] = schema[propName] || {}; if (typeof propSchema === 'string' || propSchema instanceof Array) { propSchema = schema[propName] = { type: propSchema }; } if ('type' in propSchema &amp;&amp; !(propSchema.type instanceof Array)) { propSchema.type = [ propSchema.type ]; } if (RUNTIME_CHECKS &amp;&amp; propSchema.type) { for (var i = 0, n = propSchema.type.length; i &lt; n; ++i) { if (typeof propSchema.type[i] !== 'string') { throw 'All property type identifiers must be strings; ' + propName + '\\'s is not'; } } } props[propName] = { enumerable: true, get: propSchema.getter === false ? undefined : makeGetter(propName, propSchema), set: propSchema.setter === false ? undefined : makeSetter(propName, propSchema), }; } Object.defineProperties(RecordSubclass.prototype, props); return RecordSubclass; }; return Record; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([ './extend', './event-emitter', './event-listener' ], moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(require('./extend'), require('./event-emitter'), require('./event-listener')); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.Record = moduleFactory(bff.extend, bff.eventEmitter, bff.eventListener); } }()); × Search results Close "},"view.js.html":{"id":"view.js.html","title":"Source: view.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Source: view.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; /** * ## bff/view * Encapsulates typical MVC view functionality. Note that BFF lacks a separate controller module and it is not wrong put controller logic in BFF Views. * * The intended way to combine BFF Records/Lists and Views into some kind or MVC-like pattern is as follows: * * Views listen to DOM events, and reacts to those by mutating data layer entities (such as models or lists of models) * * Views also listen to data layer events and reacts to those, possibly by further mutating the data layer (i.e. controller logic), but most importantly by re-rendering themselves. * * Another way of describing the above is that the views should, besides listening to user generated events, always strive to visually represent the data layer as truthfully as possible. A powerful and simple approach to achieving this is to re-render the whole view whenever the data layer changes. * * The three major issues to deal with when re-rendering an entire view are: * * _Loss of view state._ This is a generic problem, that thankfully has an easy solution; store all application state in the data layer. A typical way of doing this is to assign a view state model to views that are not stateless. * * _Loss of event listeners_. The typical solution to this is event delegation, which is also the soliution that BFF Views provide. All event listeners are registered on the view's root element and as long as the root elements is not replaced, the event listeners will be unaffecte by a re-render. * * _Visual flickering_. Replacing large chunks of the visual DOM may cause flickering. BFF Views work around this issue by using an approach similar to that of React, namely by differentially updating the DOM. This means doing an offline diff and then only updating the parts of the DOM that have actually changed. * @exports bff/view */ function moduleFactory(extend, eventListener, patch, List) { var HTML_PARSER_EL = document.createElement('div'); /** * Creates a new View instance. * @constructor * @mixes module:bff/event-listener * @alias module:bff/view */ function View() { Object.defineProperty(this, '__private', { writable: true, value: {}, }); this.__private.isRenderRequested = false; var delegates = this.__private.eventDelegates = {}; this.__private.onDelegatedEvent = function onDelegatedEvent(ev) { var delegatesForEvent = delegates[ev.type]; var el = ev.target; for (var selector in delegatesForEvent) { if (!el.matches(selector)) { continue; } // TODO: IE9 support (msMatchesSelector) var delegatesForEventAndSelector = delegatesForEvent[selector]; for (var i = 0, n = delegatesForEventAndSelector.length; i &lt; n; ++i) { //console.log(ev.type, selector, ev.target); delegatesForEventAndSelector[i](ev); } } }; this.__private.childViews = new List(); this.listenTo(this.__private.childViews, 'item:removed', function (childView) { childView.destroy(); }); } extend(View.prototype, eventListener); extend(View.prototype, { /** * @instance * Destroys a view instance by removing its children, stop listening to all events and finally removing itself from the DOM. */ destroy: function () { this.removeChildren(); this.stopListening(); this.el &amp;&amp; this.el.parentNode &amp;&amp; this.el.parentNode.removeChild(this.el); }, /** * Creates a subclass constructor function, that will create view instances with the properties (typically functions) provded to this function. * TODO: move this to View.makeSubclass * @instance * @arg {object} properties - The properties with which the View subclass' prototype will be extended. * @returns {function} */ makeSubclass: function (properties) { if (RUNTIME_CHECKS &amp;&amp; typeof properties !== 'object') { throw '&quot;properties&quot; argument must be an object'; } var superclass = this; var customConstructor = properties.constructor; var Constructor = function SubClassConstructor() { superclass.constructor.apply(this, arguments); customConstructor &amp;&amp; customConstructor.apply(this, arguments); }; delete properties.constructor; Constructor.prototype = Object.create(this); properties &amp;&amp; extend(Constructor.prototype, properties); Constructor.prototype.constructor = Constructor; return Constructor; }, /** * Creates a DOM representation of the view, based on the HTML string returned by the getHtml() function and then assigns it to the view's `el` property. If the view already has an `el`, it will be patched instead of replaced, so that delegated event listeners will be preserved. * @instance * @arg {Object} [patchOptions] - Options object forwarded to the `patch()` function, in case it is called. */ render: function (patchOptions) { if (RUNTIME_CHECKS) { if (!this.getHtml) { throw 'You must implement getHtml() in order to use render()'; } if (arguments.length &gt; 1 &amp;&amp; typeof patchOptions !== 'object') { throw '&quot;patchOptions&quot; argument must be an object'; } } var newEl = this.parseHtml(this.getHtml()); this.doPatch || newEl.setAttribute('patch-ignore', ''); if (this.el) { patch(this.el, newEl, patchOptions); } else { this.el = newEl; } }, /** * Requests an animation frame, in which `render()` is called. Can be called several times during a tick witout any performance penalty. * @instance */ requestRender: function () { if (this.__private.isRenderRequested) { return; } this.__private.isRenderRequested = true; var self = this; requestAnimationFrame(function () { self.__private.isRenderRequested = false; self.render(); }); }, /** * Helper function that parses an HTML string into an HTMLElement hierarchy and returns the first element in the NodeList, unless the returnAll flag is true, in which case the whole node list is returned. * @instance * @arg {string} htmlString - The string to be parsed * @arg {boolean} returnAll - If true will return all top level elements */ parseHtml: function (htmlString, returnAll) { if (RUNTIME_CHECKS) { if (typeof htmlString !== 'string') { throw '&quot;htmlString&quot; argument must be a string'; } if (arguments.length &gt; 1 &amp;&amp; typeof returnAll !== 'boolean') { throw '&quot;returnAll&quot; argument must be a boolean value'; } } HTML_PARSER_EL.innerHTML = htmlString; return returnAll ? HTML_PARSER_EL.childNodes : HTML_PARSER_EL.firstChild; }, /** * Scoped query selector, that only queries this view's DOM subtree. * @instance * @arg {string} queryString - CSS selector string */ $: function (queryString) { if (RUNTIME_CHECKS &amp;&amp; typeof queryString !== 'string') { throw '&quot;queryString&quot; argument must be a string'; } return this.el.querySelector(queryString); }, /** * Helper function that forces the view's root element to be repainted. Useful when re-triggering CSS animations. * @instance * @arg {HTMLElement} [el] Element that will be forced to repaint. If not specified, will default to the view's root element. * @returns {number} Useless/arbitrary value, but the function needs to return it to prevent browser JS optimizations from interfering with the forced repaint. */ forceRepaint: function (el) { if (RUNTIME_CHECKS &amp;&amp; arguments.length &gt; 0 &amp;&amp; !(el instanceof HTMLElement)) { throw '&quot;el&quot; argument must be an HTMLElement'; } return (el || this.el).offsetHeight; }, /** * Adds another view as a child to the view. A child view will be automatically added to this view's root element and destroyed whenever its parent view is destroyed. * @instance * @arg {module:bff/view} childView - The view that will be added to the list of this view's children. * @arg {HTMLElement} [optional] - An element to which the child view's root element will be appended. If not specified, it will be appended to this view's root element. */ addChild: function (childView, el) { if (RUNTIME_CHECKS) { if (!(childView instanceof View)) { throw '&quot;childView&quot; argument must be a BFF View'; } if (arguments.length &gt; 1 &amp;&amp; !(el instanceof HTMLElement)) { throw '&quot;el&quot; argument must be an HTMLElement'; } } this.__private.childViews.push(childView); el = el || this.el; el &amp;&amp; el.appendChild(childView.el); return childView; }, /** * Removes a specified view from this view's list of child views and destroy the view. * @instance * @arg {module:bff/view} childView - The view to remove. */ removeChild: function (childView) { if (RUNTIME_CHECKS &amp;&amp; !(childView instanceof View)) { throw '&quot;childView&quot; argument must be a BFF View'; } this.__private.childViews.remove(childView); return childView; }, /** * Removes all child views of this view. * @instance */ removeChildren: function () { this.__private.childViews.clear(); }, /** * Augments {@link module:bff/event-listener#listenTo} with functionality for listening to delegated DOM events, by specifying a CSS selector string instead of an event emitter. The actual listener will implicitly be registered on this view's root element. * @instance * @arg {string|Object|Array|NodeList} selectorStr - The CSS selector string that will be used to filter all events bubbling up to the listener. If anything other than a string passed, the original listenTo implementation will be used. * @arg {string|Array} eventName - One or more string identifiers for events that will be listented to. * @arg {function} callback - The function that will be called when the event is emitted. * @arg {any} [context] - The context with which the callback will be called (i.e. what &quot;this&quot; will be). * Will default to the caller of .listenTo, if not provided. */ listenTo: function (selectorStr, eventName, callback, context, useCapture) { if (typeof selectorStr !== 'string') { eventListener.listenTo.apply(this, arguments); return; } if (eventName instanceof Array &amp;&amp; eventName.length &gt; 0) { this.listenTo(selectorStr, eventName.pop(), callback, context, useCapture); this.listenTo(selectorStr, eventName, callback, context, useCapture); return; } if (RUNTIME_CHECKS) { if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; } if (arguments.length &gt; 4 &amp;&amp; typeof useCapture !== 'boolean') { throw '&quot;useCapture&quot; argument must be a boolean value'; } } var delegates = this.__private.eventDelegates; var delegatesForEvent = delegates[eventName]; var firstTimeListeningToEvent = false; if (!delegatesForEvent) { delegatesForEvent = (delegates[eventName] = {}); firstTimeListeningToEvent = true; useCapture = useCapture || eventName === 'blur' || eventName === 'focus'; eventListener.listenTo.call(this, this.el, eventName, this.__private.onDelegatedEvent, undefined, useCapture); } delegatesForEvent[selectorStr] = delegatesForEvent[selectorStr] || []; delegatesForEvent[selectorStr].push(callback.bind(context || this)); }, /** * Augments {@link module:bff/event-listener#stopListening} with functionality for stop listening to delegated DOM events. * @instance * @arg {string|Object} [selectorStr] - If provided, only delegated event callbacks for the given selector string will be removed. If anything other than a string passed, the original stopListening implementation will be used. * @arg {string} [eventName] - If provided, only callbacks attached to the given event name will be removed. */ stopListening: function (selectorStr, eventName) { if (typeof selectorStr !== 'string') { eventListener.stopListening.apply(this, arguments); return; } if (RUNTIME_CHECKS &amp;&amp; arguments.length &gt; 1 &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } var delegatesForEvent = this.__private.eventDelegates[eventName]; if (!delegatesForEvent) { return; } delete delegatesForEvent[selectorStr]; if (Object.keys(delegatesForEvent).length === 0) { delete this.__private.eventDelegates[eventName]; eventListener.stopListening.call(this, this.el, eventName); } }, /** * @instance * @returns {string} A human readable representation of the View, containing valuable debugging information. */ toString: function () { return JSON.stringify({ 'element': this.el &amp;&amp; { type: '&lt;' + this.el.nodeName + '&gt;', children: this.el.childNodes.length, }, 'child views': this.__private.childViews.length, 'event listeners': Object.keys(this.__private.listeningTo), 'delegated events': Object.keys(this.__private.eventDelegates), }, undefined, 2); }, }, 'useSource'); return View; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([ './extend', './event-listener', './patch-dom', './list' ], moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory( require('./extend'), require('./event-listener'), require('./patch-dom'), require('./list')); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.View = moduleFactory(bff.extend, bff.eventListener, bff.patchDom, bff.List); } }()); × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Modules Classes module:bff/list module:bff/record module:bff/view Mixins bff/event-emitter bff/event-listener Events change:length Parameters: Name Type Description newLength number The current length of the List. oldLength number The previous length of the List. list module:bff/list The List whose length has changed. Source: list.js, line 40 item:added Parameters: Name Type Description item any The item that was added to the List. index number The position withing the List where the item was added. list module:bff/list The List to which the item was added. Source: list.js, line 18 item:removed Parameters: Name Type Description item any The item that was removed from the List. index number The position withing the List where the item was removed. list module:bff/list The List from which the item was removed. Source: list.js, line 33 item:replaced Parameters: Name Type Description newItem any The item that was added to the List. oldItem any The item that was removed from the List. index number The position withing the List where the item was replaced. list module:bff/list The List in which the item was replaced. Source: list.js, line 25 × Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Mixins Classes module:bff/list module:bff/record module:bff/view Mixins bff/event-emitter bff/event-listener Events change:length Parameters: Name Type Description newLength number The current length of the List. oldLength number The previous length of the List. list module:bff/list The List whose length has changed. Source: list.js, line 40 item:added Parameters: Name Type Description item any The item that was added to the List. index number The position withing the List where the item was added. list module:bff/list The List to which the item was added. Source: list.js, line 18 item:removed Parameters: Name Type Description item any The item that was removed from the List. index number The position withing the List where the item was removed. list module:bff/list The List from which the item was removed. Source: list.js, line 33 item:replaced Parameters: Name Type Description newItem any The item that was added to the List. oldItem any The item that was removed from the List. index number The position withing the List where the item was replaced. list module:bff/list The List in which the item was replaced. Source: list.js, line 25 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced × Search results Close "},"bff_event-emitter.html":{"id":"bff_event-emitter.html","title":"Mixin: bff/event-emitter","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Mixin: bff/event-emitter bff/event-emitter A mixin, providing event emitting capabilities to an object. Events are simply strings. When they are emitted, zero or more parameters can be passed as arguments to the listening functions. Source: event-emitter.js, line 12 Methods addEventListener(eventName, callback) Add an event listener function that will be called whenever the given event is emitted. Trying to add the exact same function twice till throw an error, as that is rarely ever the intention and a common source of errors. Parameters: Name Type Description eventName string Identifier string for the event that is to be listened to. callback function The function that will be called when the event is emitted. Source: event-emitter.js, line 69 emit(eventName, eventArguments) Emit an event. Callbacks will be called with the same arguments as this function was called with, except for the event name argument. Parameters: Name Type Argument Description eventName string Identifier string for the event. eventArguments any &lt;optional&gt; &lt;repeatable&gt; Zero or more arguments that event listeners will be called with. Source: event-emitter.js, line 19 emitArgsAsArray(eventName, argsArray) Emit an event. Callbacks will be called with arguments given as an an array in the second argument Parameters: Name Type Argument Description eventName string Identifier string for the event. argsArray array &lt;optional&gt; An array of arguments with which the callbacks will be called. Each item in the array will be provided as an individual argument to the callbacks. Source: event-emitter.js, line 43 removeEventListener(eventName, callback) Removes an event listener function. If the function was never a listener, do nothing. Parameters: Name Type Argument Description eventName string Identifier string for the event in question. callback function &lt;optional&gt; If not given, all event listeners to the provided eventName will be removed. If given, only the given callback will be removed from the given eventName. Source: event-emitter.js, line 96 × Search results Close "},"bff_event-listener.html":{"id":"bff_event-listener.html","title":"Mixin: bff/event-listener","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Mixin: bff/event-listener bff/event-listener A mixin, providing event listening capabilities to an object. This is an inversion-of-control with regards to regular event listening; the listener maintains a list of the events it is listening to. This allows the listener to remove some or all its event listeners, for instance when it is disabled or destroyed. This is an easy way to avoid leaking listeners. Caveat: don't mix eventEmitter.removeEventListener and eventListener.stopListening throughout a project, as that could result in memory leaks. Source: event-listener.js, line 44 Methods listenTo(eventEmitters, eventNames, callback, context) Start listening to an event on a specified event emitting object. Both eventEmitters and eventNames arguments can be arrays. The total amount of listeners added will be the Cartesian product of the two lists. Parameters: Name Type Argument Description eventEmitters Object | Array | NodeList One or more event emitters that will be listened to. eventNames string | Array One or more string identifiers for events that will be listented to. callback function The function that will be called when the event is emitted. context any &lt;optional&gt; The context with which the callback will be called (i.e. what &quot;this&quot; will be). Will default to the caller of .listenTo, if not provided. Source: event-listener.js, line 55 stopListening(eventEmitter, eventName) Stop listening to events. If no arguments are provided, the listener removes all its event listeners. Providing any or both of the optional arguments will filter the list of event listeners removed. Parameters: Name Type Argument Description eventEmitter Object &lt;optional&gt; If provided, only callbacks attached to the given event emitter will be removed. eventName string &lt;optional&gt; If provided, only callbacks attached to the given event name will be removed. Source: event-listener.js, line 91 × Search results Close "},"module-bff_extend.html":{"id":"module-bff_extend.html","title":"Module: bff/extend","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Module: bff/extend bff/extend (require(&quot;bff/extend&quot;))(target, source, onConflict, defaultOnConflict) A function that extends a target object with the properties of a source object, with options for describing property collision behavior. Note that the target object is mutated and returned, i.e. no new object gets created by invoking this function. The function comes with a set of named built-in conflict-solving functions: crash: Throws an error when a property conflict occurs. This is the default solver function. useTarget: Uses the target's property, i.e. leaves the target property unchanged. useSource: Uses the source's property, i.e. overwrites the target property with the source property. merge: Tries to merge the values in an intuitive way. Objects are merged recursively. Arrays are concatenated. Functions are combined, so that the target's function is first called, then the source's. Both functions are passed the same arguments. Numbers and strings added using the + operator. Boolean values are or:ed using the || operator (i.e. Boolean addition). If the source and target types are not the same, use the source value.The caller also has the option to specify custom solver functions. Examples extend( { a: { b: 'b', c: 'c' } }, { a: { c: 'c', d: 'd' } }, 'useSource'); // Returns { a: { c: 'c', d: 'd' } }As can be seen in above, the 'useSource' conflict solver is not recursive, it simply overwrites any property it encounters. This is how e.g. jQuery.extend and _.assign behaves. extend( { a: { b: 'b', c: 'c' } }, { a: { c: 'c', d: 'd' } }, 'merge'); // Returns { a: { b: 'b', c: 'c', d: 'd' } }Here we see that the 'merge' solver works recursively. extend( { a: { b: 'b' }, num: 1 }, { a: { c: 'c' }, num: 2 }, { object: 'merge' }, 'useSource'); // Returns { a: { b: 'b', c: 'c' }, num: 2 }The above example uses the 'merge' solver on objects and the 'useSource' solver on all other property types. This produces a recursive behavior over objects, which is quite often desired. This is how e.g. _.merge behaves extend( { a: { b: 'b' }, num: 1 }, { a: { c: 'c' }, num: 2, newProp: 3 }, function (target, source, prop) { target[prop] = 42; }); // Returns { a: 42, num: 42, newProp: 3 }Above we see a (fairly useless) custom conflict solver function. Parameters: Name Type Argument Description target Object The object that will be extende with new properties. source Object The object that provides the new properties. onConflict string | module:bff/extend~conflictSolver | Object &lt;optional&gt; Specifies how to handle cases where a property exists both on the target and on the source. a string argument will be used to identify one of the built in solver functions. Valid values are 'useTarget', 'useSouce', 'crash' and 'merge'. a function argument will be used as-is as a solver for all conflicts. an Object argument should have keys that correspond to value types, i.e. 'object', 'array', 'function', 'string', 'number', 'boolean', 'null' or 'undefined'. The object values can be either strings or functions, which will be used as solver functions for the corresponding key value types. defaultOnConflict string | module:bff/extend~conflictSolver &lt;optional&gt; Specifies a default solver, in the same manner as the onConflict argument. Can only be used if onConflict is an object. Source: extend.js, line 86 Returns: The extended object Type Object Type Definitions conflictSolver(target, source, prop, onConflict, defaultOnConflict) Parameters: Name Type Description target Object source Object prop string The name of the conflicting property. onConflict string | module:bff/extend~conflictSolver | Object The same onConflict argumet passed to the extend() call. defaultOnConflict string | module:bff/extend~conflictSolver The same defaultOnConfluct argumet passed to the extend() call. Source: extend.js, line 18 × Search results Close "},"module-bff_list.html":{"id":"module-bff_list.html","title":"Module: bff/list","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Module: bff/list bff/listMaintains a list of items. The idea is to stay as true as possible to the native Array interface, but to augment its usefulness by triggering events whenever the list is updated, as well as adding convenience functions for mutating the List in place. The exported List constructor can be used as-is, in which case a generic List will be created. This is a quite common use case. Alternatively, a List &quot;subclass&quot; constructor can be created by calling List.withProperties(...). This second approach provides the possibility to add custom calculated properties to the list. See module:bff/list#withProperties for more details. new (require(&quot;bff/list&quot;))(items) Creates a new List, with an optional list or array of initial items. Parameters: Name Type Argument Description items Array | List &lt;optional&gt; Items that will be added to the List on creation. Mixes In: bff/event-emitter bff/event-listener Source: list.js, line 785 Methods &lt;static&gt; withProperties(schema) Creates a new List constructor function, that will create List instances with the property schemaprovided to this function Parameters: Name Type Description schema Object An object describing the properties that will be part of all new instances created by the returned constructor function. The property descriptions should be on the same format at the schema specified for module:bff/record#withProperties, with the only exception that setters are not allowed. Source: list.js, line 795 Returns: New constructor function based on the provided schema. Type function addEventListener(eventName) Augmented version of module:bff/event-emitter#addEventListener that provides the option to listen to events emitted from any item in the List. To add a listener to an item event, prepend the event name with 'item:'. For instance, to listen for the 'change' event on all the list items (even ones added after the listener was created), add a listener for the 'item:change' event. Parameters: Name Type Description eventName string Identifier string for the event. Source: list.js, line 655 clear() Mutates the List by removing all items. Source: list.js, line 495 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: The List, now empty. Type List concat(value) Returns a new List comprised of the List on which it is called joined with the List(s), Array(s) and/or value(s) provided as arguments. Mirrors the behavior of Array.concat. Parameters: Name Type Argument Description value any &lt;repeatable&gt; A List, Array or value that will be concatenated with the original List. Lists and Arrays will be deconstructed and each item added to the new List. Source: list.js, line 440 Returns: The new List. Type List every(predicate, thisArg) Mirrors Array.every behavior. Parameters: Name Type Argument Description predicate module:bff/list~predicateCallback Executed once per List item. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 318 Returns: true if all items passes the predicate test, false otherwise. Type boolean filter(predicate) Creates a new List with all items that pass the test implemented by the predicate function test. The original list is unchanged. Mirrors the behavior of Array.filter. Parameters: Name Type Description predicate module:bff/list~predicateCallback Executed once per List item. Source: list.js, line 402 Returns: The new List. Type List filterMut(predicate, thisArg) Mutates the List by removing all items that does not pass the predicate function test. Parameters: Name Type Argument Description predicate module:bff/list~predicateCallback Called once per List item to determine whether the item should be removed. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing predicate callback. Source: list.js, line 459 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: The filtered List. Type List find(predicate) Returns the first item in the List that passes the predicate function test, or undefined if no item passes. Parameters: Name Type Description predicate module:bff/list~predicateCallback Called once per List item to in order to find a matching item. Source: list.js, line 577 Returns: The matching item, if any. Type any | undefined findIndex(predicate) Returns the index of the first item in the List that passes the predicate function test, or -1 if no item passes. Parameters: Name Type Description predicate module:bff/list~predicateCallback Called once per List item to in order to find a matching item. Source: list.js, line 591 Returns: The position of the matching item, or -1 if none matches. Type number forEach(callback, thisArg) Executes the given function once per List item. Mirrors Array.forEach behavior. Parameters: Name Type Argument Description callback module:bff/list~forEachCallback The function that will be called once per List item. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 310 includes(item, fromIndex) Returns whether the provided item is part of the List. Parameters: Name Type Argument Description item any fromIndex number &lt;optional&gt; The index to start the search at. If the index is greater than or equal to the List's length, -1 is returned, which means the List will not be searched. If the provided index value is a negative number, it is taken as the offset from the end of the List. Source: list.js, line 607 Returns: True if the item is part of the List, false otherwise. Type boolean indexOf(searchItem, fromIndex) Mirrors Array.indexOf behavior. Parameters: Name Type Argument Description searchItem any The item to locate within the List. fromIndex number &lt;optional&gt; The index to start the search at. If the index is greater than or equal to the List's length, -1 is returned, which means the List will not be searched. If the provided index value is a negative number, it is taken as the offset from the end of the List. Source: list.js, line 336 Returns: The first index at which a given item can be found in the List, or -1 if it is not present. Type number join(separator) Parameters: Name Type Argument Description separator string &lt;optional&gt; Specifies a string to separate each item of the List. If omitted, the List items are separated with a comma. Mirrors Array.join behavior. Source: list.js, line 353 Returns: The stringified List items, joined by the 'separator' string argument. Type string lastIndexOf(searchItem, fromIndex) Parameters: Name Type Argument Description searchItem any The item to locate within the List. fromIndex number &lt;optional&gt; The index at which to start searching backwards. Defaults to the List's length minus one, i.e. the whole List will be searched. If the index is greater than or equal to the length of the List, the whole List will be searched. If negative, it is taken as the offset from the end of the List. Mirrors Array.lastIndexOf behavior. Source: list.js, line 345 Returns: The last index at which a given item can be found in the List, or -1 if it is not present. Type number map(callback, thisArg) Creates a new List with the results of calling a provided callback function on every element in the List. Mirrors the behavior of Array.map. Parameters: Name Type Argument Description callback module:bff/module~mapCallback Executed once per List item. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 421 Returns: The new List. Type List mapMut(callback, thisArg) Replaces all items in the List with new items, generated by the callback function. Parameters: Name Type Argument Description callback module:bff/module~mapCallback Executed once per List item to produce new items. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 562 Fires: module:bff/list#item:replaced Returns: The List, with all items updated. Type List pop() Remove and return one item from the end of the List. Mirrors Array.pop behavior. Source: list.js, line 230 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: Removed item Type any propertiesToJSON() Returns a newly created Object containing the List's deep copied properties. Source: list.js, line 646 Returns: Type Object push(item) Add one or more items to the end of the List. Mirrors Array.push behavior. Parameters: Name Type Argument Description item any &lt;repeatable&gt; Each item argument will be pushed onto the List. Source: list.js, line 181 Fires: module:bff/list#change:length module:bff/list#item:added Returns: Updated List length Type number pushAll(items) Mutates the List by adding the items comprising the provided List or Array to the end of the List. Parameters: Name Type Description items module:bff/list | Array The items that will be appended to the List. Source: list.js, line 507 Fires: module:bff/list#change:length module:bff/list#item:added Returns: The List, with new items appended. Type List reduce(callback, initialValue) Applies a function against an accumulator and each value of the List (from left-to-right) to reduce it to a single value. Mirrors Array.reduce behavior. Parameters: Name Type Description callback module:bff/list~reduceCallback The function that will be called once per List item. initialValue any Value to use as the first argument to the first call of the callback. Source: list.js, line 360 Returns: Aggregated value Type any reduceRight(callback, initialValue) Applies a function against an accumulator and each value of the List (from right-to-left) to reduce it to a single value. Mirrors Array.reduceRight behavior. Parameters: Name Type Description callback module:bff/list~reduceCallback The function that will be called once per List item. initialValue any Value to use as the first argument to the first call of the callback. Source: list.js, line 369 Returns: Aggregated value Type any remove(item) Mutates the List by removing all occurances of the provided item. Parameters: Name Type Description item any The item to remove from the list. Source: list.js, line 484 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: The List, without any occurances of 'item'. Type List removeEventListener(eventName) Augmented version of module:bff/event-emitter#addEventListener that provides functionality for removing &quot;item&quot; event listeners, e.g. for stop listening to events like &quot;items:change&quot;. Parameters: Name Type Description eventName string Identifier string for the event. Source: list.js, line 675 reverse() Reverses the List in place. Mirros the behavior of Array.reverse. No events are emitted by this operation. Source: list.js, line 391 shift() Remove and return one item from the beginning of the List. Mirrors Array.shift behavior. Source: list.js, line 251 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: Removed item Type any slice(begin, end) Creates a new List from the range of current items specified by the begin and end arguments. Mirrors the behavior of Array.slice. Parameters: Name Type Argument Description begin number &lt;optional&gt; Index that specifies the beginning of the range. Inclusive. A negative index will be relative to the end of the List instead of the beginning. end number &lt;optional&gt; Index that specifies the end of the range. Exclusive. A negative index will be relative to the end of the List instead of the beginning. Source: list.js, line 410 Returns: The new List. Type List sliceMut(begin, end) Mutates the List by removing all elements outside of range specified by the begin and end arguments. Parameters: Name Type Argument Description begin number &lt;optional&gt; Index that specifies the beginning of the range. Inclusive. A negative index will be relative to the end of the List instead of the beginning. end number &lt;optional&gt; Index that specifies the end of the range. Exclusive. A negative index will be relative to the end of the List instead of the beginning. Source: list.js, line 524 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: The List, sans the items outside of the specified range. Type List some(predicate, thisArg) Mirrors Array.some behavior. Parameters: Name Type Argument Description predicate module:bff/list~predicateCallback Executed once per List item. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 327 Returns: true if at least one item passes the predicate test, false otherwise. Type boolean sort(comparator) Sorts the items of the List in place. The sort is not necessarily stable. The default sort order is according to string Unicode code points, unless a custom comparator finction is provided. Mirrors the behavior of Array.sort. No events are emitted by this operation. Parameters: Name Type Argument Description comparator module:bff/list~compareFunction &lt;optional&gt; A function that specifies the ordering of two arbitrary List items. Called multiple times in order to produce a total ordering of the items. Source: list.js, line 383 Returns: The sorted list. Type List splice(start, nItemsToRemove, itemToAdd) Changes the content of the List by removing existing items and/or adding new items. Mirrors Array.splice behavior. Parameters: Name Type Argument Description start number Index at which to start changing the array. If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many items from the end. nItemsToRemove number An integer indicating the number of old array items to remove. If nItemsToRemove is greater than the number of items left in the array starting at start, then all of the items through the end of the array will be deleted. itemToAdd any &lt;optional&gt; &lt;repeatable&gt; Item that will be added to the array, starting at the index specified in the first argument. Source: list.js, line 277 Fires: module:bff/list#change:length module:bff/list#item:added module:bff/list#item:replaced module:bff/list#item:removed Returns: Array of removed items Type Array.&lt;any&gt; toArray() Returns an newly created Array, containing all the items of the List. List properties are not copied to the Array object. The items are copied shallowly. Source: list.js, line 622 Returns: Type Array toJSON() Returns a newly created Array representation of the List, containing deep copies of all the List's items, but not its properties. Source: list.js, line 631 Returns: Type Array toString() Source: list.js, line 697 Returns: A human readable string representation of the List. Type string unshift(item) Add one or more items to the beginning of the List. Mirrors Array.unshift behavior. Parameters: Name Type Argument Description item any &lt;repeatable&gt; Each item argument will be pushed onto the List. Source: list.js, line 206 Fires: module:bff/list#change:length module:bff/list#item:added Returns: Updated List length Type Number Type Definitions compareFunction(itemA, itemB) Compares itemA and itemB arguments according to some sorting criterion. Should return -1 if itemA comes before itemB, 0 if itemA is equal to itemB, 1 if itemB comes before itemA. Parameters: Name Type Description itemA any A list item. itemB any Another list item. Source: list.js, line 86 Returns: . Type number forEachCallback(item, index, list) Parameters: Name Type Description item any Current List item. index number Item position in List. list module:bff/list List being iterated over. Source: list.js, line 54 mapCallback(item, index, list) Parameters: Name Type Description item any Current List item. index number Item position in List. list module:bff/list List being iterated over. Source: list.js, line 61 Returns: Transformed object. Type any predicateCallback(item, index, list) Parameters: Name Type Description item any Current List item. index number Item position in List. list module:bff/list List being iterated over. Source: list.js, line 69 Returns: true if the item passes the test, false otherwise Type boolean reduceCallback(previousItem, item, index, list) Parameters: Name Type Description previousItem any The value previously returned in the last invocation of the callback, or initialValue, if supplied. Usually an aggregate of previous items. item any Current List item being processed. index number Item position in List. list module:bff/list List being iterated over. Source: list.js, line 77 Returns: The aggregated value. Type any Events change:length Parameters: Name Type Description newLength number The current length of the List. oldLength number The previous length of the List. list module:bff/list The List whose length has changed. Source: list.js, line 40 item:added Parameters: Name Type Description item any The item that was added to the List. index number The position withing the List where the item was added. list module:bff/list The List to which the item was added. Source: list.js, line 18 item:removed Parameters: Name Type Description item any The item that was removed from the List. index number The position withing the List where the item was removed. list module:bff/list The List from which the item was removed. Source: list.js, line 33 item:replaced Parameters: Name Type Description newItem any The item that was added to the List. oldItem any The item that was removed from the List. index number The position withing the List where the item was replaced. list module:bff/list The List in which the item was replaced. Source: list.js, line 25 × Search results Close "},"module-bff_patch-dom.html":{"id":"module-bff_patch-dom.html","title":"Module: bff/patch-dom","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Module: bff/patch-dom bff/patch-dom (require(&quot;bff/patch-dom&quot;))(target, source, options) Patches the target element and its child elements such that it will be identical to the source element and its child structure. It achieves this by recursively patching, removing or adding elements in the target element hierarchy. The overall logic of the algorithm goes as follows: If the target and source elements have differing node type types (e.g. a &lt;div&gt; and a &lt;span&gt; tag) the target element is replaced by the source element. Otherwise, if the target and source elements are of the same type (e.g. two &lt;div&gt; tags), the attributes of the target element will be replaced by those of the target element. Then the target and source elements' children lists are compared using a version of the Levenshtein algorithm. This results in the children of the target element being either patched (by calling patchDom recursively) or removed. Child elements only present in the source child list will also be added to the target child list at their respective positions. If any encountered target elements has a patch-ignore attribute, that node and its children will not be patched. Parameters: Name Type Argument Description target HTMLElement The element (hierarchy) to be patched. Will be identical to the source element (hierarchy) after the function call completes. source HTMLElement The element (hierarchy) that the target (hierarchy) will be transformed into. options Object &lt;optional&gt; Options that will be recursively passed down to all patchDom calls. Currently only one option is implemented: ignoreSubtreeOf: A CSS selector string that identifies any elements, whose subtrees will not be patched. Source: patch-dom.js, line 239 × Search results Close "},"module-bff_record.html":{"id":"module-bff_record.html","title":"Module: bff/record","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Module: bff/record bff/recordA Record is the basic entity of the data layer. In difference to regular JS objects, it has a predefined set of properties. The properties are specified by &quot;subclassing&quot; the abstract Record constructor by calling Record.withProperties(...) and providing a properties schema. For more details, see module:bff/record#withProperties. The major advantages of using a predefined (i.e. known and finite) set of properties are: Each property gets a custom setter, that emits a change event whenever the property value changes. The setter can also do types checks on the assigned value (which it does in dev. mode). The record instances can be locked using Object.preventExtensions, with the nice effect that trying to assign a value to an undeclared property will throw an error. new (require(&quot;bff/record&quot;))(values) Creates a new Record (subclass) with an optional set of initial values. Parameters: Name Type Argument Description values Object | module:bff/record &lt;optional&gt; An object containing initial values for the Record to be created. Mixes In: bff/event-emitter bff/event-listener Source: record.js, line 70 Methods &lt;static&gt; withProperties(schema) Creates a new Record constructor function, that will create Record instances with the property schema provided to this function. The various aspects of the property schema are described in detail below, but let's start with an example. var Person = Record.withProperties({ firstName: 'string', lastName: 'string', fullName: { setter: false, getter: function () { return this.firstName + ' ' + this.lastName; }, dependencies: [ 'firstName', 'lastName' ], }, age: { type: [ 'number', undefined ], defaultValue: 0, }, someData: {}, })Here we see a schema with five properties. The first two (firstName and lastName) use a shorthand syntax to declare string properties. The fullName property is a calculated property that depends on firstName and lastName. The age property is either a number or undefined (properties can't be undefined by default), with a default value of 0. Finally, the someData property can be of any type. Parameters: Name Type Description schema Object An object describing the properties that will be part of all new instances created by the returned constructor function. Each key/value pair describes a single property. Property descriptor objects can have the following properties: type: A string or array of strings specifying the type of the property. If omitted, no type checking will be performed, otherwise types are checked by applying the typeof operator to the assigned value and then checking to see if the returned type string is part of the schema types. defaultValue: An initial value that will be assigned to all new instances of this property upon creation. setter: A function that will be called to transform the assigned value before it is stored on the property. Shouldn't have any side effects, as it might be called internally to determine when events should be triggered. getter: A function that will be run to transform the read value before it is returned. Shouldn't have any side effects, as it might be called internally to determine when events should be triggered. All schema descriptor properties are optional. An empty schema descriptor can be replaced with any falsy value for the same effect, which means that:someData: {}, someData: undefined, someData: null and someData: false all declares a property named someData, which can hold any type of data. There is also a shorthand syntax for specifying typed properties, because it is such a common use case, e.g.:aProp: 'string' is equal to aProp: { type: 'string' } and e.g.aProp: [ 'string', 'undefined' ] is equal to aProp: { type: [ 'string', 'undefined' ] } Source: record.js, line 193 Returns: New constructor function based on the provided schema. Type function toJSON() Returns a newly created Object containing the Records's deep copied properties. The fact that this function returns an Object and not a strin is a bit misleading, but this naming convension is used for conformity reasons, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON_behavior Source: record.js, line 137 Returns: Type Object toString() Source: record.js, line 150 Returns: A human readable string representation of the Record. Type string × Search results Close "},"module-bff_view.html":{"id":"module-bff_view.html","title":"Module: bff/view","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replaced Module: bff/view bff/viewEncapsulates typical MVC view functionality. Note that BFF lacks a separate controller module and it is not wrong put controller logic in BFF Views. The intended way to combine BFF Records/Lists and Views into some kind or MVC-like pattern is as follows: Views listen to DOM events, and reacts to those by mutating data layer entities (such as models or lists of models) Views also listen to data layer events and reacts to those, possibly by further mutating the data layer (i.e. controller logic), but most importantly by re-rendering themselves. Another way of describing the above is that the views should, besides listening to user generated events, always strive to visually represent the data layer as truthfully as possible. A powerful and simple approach to achieving this is to re-render the whole view whenever the data layer changes. The three major issues to deal with when re-rendering an entire view are: Loss of view state. This is a generic problem, that thankfully has an easy solution; store all application state in the data layer. A typical way of doing this is to assign a view state model to views that are not stateless. Loss of event listeners. The typical solution to this is event delegation, which is also the soliution that BFF Views provide. All event listeners are registered on the view's root element and as long as the root elements is not replaced, the event listeners will be unaffecte by a re-render. Visual flickering. Replacing large chunks of the visual DOM may cause flickering. BFF Views work around this issue by using an approach similar to that of React, namely by differentially updating the DOM. This means doing an offline diff and then only updating the parts of the DOM that have actually changed. new (require(&quot;bff/view&quot;))() Creates a new View instance. Mixes In: module:bff/event-listener Source: view.js, line 31 Methods $(queryString) Scoped query selector, that only queries this view's DOM subtree. Parameters: Name Type Description queryString string CSS selector string Source: view.js, line 161 addChild(childView, optional) Adds another view as a child to the view. A child view will be automatically added to this view's root element and destroyed whenever its parent view is destroyed. Parameters: Name Type Argument Description childView module:bff/view The view that will be added to the list of this view's children. optional HTMLElement &lt;optional&gt; An element to which the child view's root element will be appended. If not specified, it will be appended to this view's root element. Source: view.js, line 188 destroy() Source: view.js, line 62 forceRepaint(el) Helper function that forces the view's root element to be repainted. Useful when re-triggering CSS animations. Parameters: Name Type Argument Description el HTMLElement &lt;optional&gt; Element that will be forced to repaint. If not specified, will default to the view's root element. Source: view.js, line 175 Returns: Useless/arbitrary value, but the function needs to return it to prevent browser JS optimizations from interfering with the forced repaint. Type number listenTo(selectorStr, eventName, callback, context) Augments module:bff/event-listener#listenTo with functionality for listening to delegated DOM events, by specifying a CSS selector string instead of an event emitter. The actual listener will implicitly be registered on this view's root element. Parameters: Name Type Argument Description selectorStr string | Object | Array | NodeList The CSS selector string that will be used to filter all events bubbling up to the listener. If anything other than a string passed, the original listenTo implementation will be used. eventName string | Array One or more string identifiers for events that will be listented to. callback function The function that will be called when the event is emitted. context any &lt;optional&gt; The context with which the callback will be called (i.e. what &quot;this&quot; will be). Will default to the caller of .listenTo, if not provided. Source: view.js, line 236 makeSubclass(properties) Creates a subclass constructor function, that will create view instances with the properties (typically functions) provded to this function.TODO: move this to View.makeSubclass Parameters: Name Type Description properties object The properties with which the View subclass' prototype will be extended. Source: view.js, line 75 Returns: Type function parseHtml(htmlString, returnAll) Helper function that parses an HTML string into an HTMLElement hierarchy and returns the first element in the NodeList, unless the returnAll flag is true, in which case the whole node list is returned. Parameters: Name Type Description htmlString string The string to be parsed returnAll boolean If true will return all top level elements Source: view.js, line 142 removeChild(childView) Removes a specified view from this view's list of child views and destroy the view. Parameters: Name Type Description childView module:bff/view The view to remove. Source: view.js, line 209 removeChildren() Removes all child views of this view. Source: view.js, line 222 render(patchOptions) Creates a DOM representation of the view, based on the HTML string returned by the getHtml() function and then assigns it to the view's el property. If the view already has an el, it will be patched instead of replaced, so that delegated event listeners will be preserved. Parameters: Name Type Argument Description patchOptions Object &lt;optional&gt; Options object forwarded to the patch() function, in case it is called. Source: view.js, line 101 requestRender() Requests an animation frame, in which render() is called. Can be called several times during a tick witout any performance penalty. Source: view.js, line 125 stopListening(selectorStr, eventName) Augments module:bff/event-listener#stopListening with functionality for stop listening to delegated DOM events. Parameters: Name Type Argument Description selectorStr string | Object &lt;optional&gt; If provided, only delegated event callbacks for the given selector string will be removed. If anything other than a string passed, the original stopListening implementation will be used. eventName string &lt;optional&gt; If provided, only callbacks attached to the given event name will be removed. Source: view.js, line 279 toString() Source: view.js, line 303 Returns: A human readable representation of the View, containing valuable debugging information. Type string × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
