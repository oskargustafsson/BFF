<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"event-emitter.js.html":{"id":"event-emitter.js.html","title":"Source: event-emitter.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Source: event-emitter.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; function moduleFactory() { /** * A mixin, providing event emitting capabilities to an object. Events are simply strings. When they are emitted, zero or more parameters can be passed as arguments to the listening functions. * @mixin * @alias bff/event-emitter */ var eventEmitter = { /** * Emit an event. Callbacks will be called with the same arguments as this function was called with, except for the event name argument. * @instance * @arg {string} eventName - Identifier string for the event. * @arg {...any} [eventArguments] - Zero or more arguments that event listeners will be called with. */ emit: function (eventName) { if (RUNTIME_CHECKS &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (!this.__private || !this.__private.listeners) { return; } var listenersForEvent = this.__private.listeners[eventName]; if (!listenersForEvent) { return; } for (var i = 0, n = listenersForEvent.length; i &lt; n; ++i) { var listener = listenersForEvent[i]; // Call the listener without the first item in the &quot;arguments&quot; array listener.call.apply(listener, arguments); } }, /** * Emit an event. Callbacks will be called with arguments given as an an array in the second argument * @instance * @arg {string} eventName - Identifier string for the event. * @arg {Array} [argsArray] - An array of arguments with which the callbacks will be called. Each item in * the array will be provided as an individual argument to the callbacks. */ emitArgsAsArray: function (eventName, argsArray) { if (RUNTIME_CHECKS) { if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (arguments.length &gt; 1 &amp;&amp; (!argsArray || argsArray.length === undefined)) { throw '&quot;argsArray&quot; must have a length property'; } } if (!this.__private || !this.__private.listeners) { return; } var listenersForEvent = this.__private.listeners[eventName]; if (!listenersForEvent) { return; } for (var i = 0, n = listenersForEvent.length; i &lt; n; ++i) { listenersForEvent[i].apply(undefined, argsArray); } }, /** * Add an event listener function that will be called whenever the given event is emitted. Trying to add the exact same function twice till throw an error, as that is rarely ever the intention and a common source of errors. * @instance * @arg {string} eventName - Identifier string for the event that is to be listened to. * @arg {function} callback - The function that will be called when the event is emitted. */ addEventListener: function (eventName, callback) { if (RUNTIME_CHECKS) { if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; } } this.__private || Object.defineProperty(this, '__private', { writable: true, value: {}, }); var listeners = this.__private.listeners || (this.__private.listeners = {}); var listenersForEvent = listeners[eventName] || (listeners[eventName] = []); if (RUNTIME_CHECKS &amp;&amp; listenersForEvent.indexOf(callback) !== -1) { throw 'This listener has already been added (event: ' + eventName + ')'; } listenersForEvent.push(callback); }, /** * Removes an event listener function. If the function was never a listener, do nothing. * @instance * @arg {string} eventName - Identifier string for the event in question. * @arg {function} [callback] - If not given, all event listeners to the provided eventName will be removed. If given, only the given callback will be removed from the given eventName. */ removeEventListener: function (eventName, callback) { if (RUNTIME_CHECKS) { if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (arguments.length === 2 &amp;&amp; typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; // Catch a common cause of errors } } // No listeners at all? We are done. if (!this.__private || !this.__private.listeners) { return; } var listenersForEvent = this.__private.listeners[eventName]; if (!listenersForEvent) { return; } // No listeners for this event? We are done. if (callback) { var pos = listenersForEvent.indexOf(callback); if (pos === -1) { return; } listenersForEvent.splice(pos, 1); } else { listenersForEvent.length = 0; } listenersForEvent.length === 0 &amp;&amp; (delete this.__private.listeners[eventName]); }, }; return eventEmitter; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.eventEmitter = moduleFactory(); } }()); × Search results Close "},"event-listener.js.html":{"id":"event-listener.js.html","title":"Source: event-listener.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Source: event-listener.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; function moduleFactory() { function filterList(listeningToList, eventName, eventEmitter) { var length = listeningToList.length; for (var i = length - 1; i &gt;= 0; --i) { var listeningTo = listeningToList[i]; if (!eventEmitter || listeningTo.emitter === eventEmitter) { listeningTo.emitter.removeEventListener(eventName, listeningTo.callback); listeningToList.splice(i, 1); } } } function setupListeners(self, eventEmitter, eventName, callback, context, useCapture) { if (RUNTIME_CHECKS) { if (!eventEmitter.addEventListener) { throw '&quot;eventEmitter&quot; argument must be an event emitter'; } if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } } self.__private || Object.defineProperty(self, '__private', { writable: true, value: {}, }); var listeningTo = self.__private.listeningTo || (self.__private.listeningTo = {}); var listeningToEvent = listeningTo[eventName] || (listeningTo[eventName] = []); callback = callback.bind(context || self); listeningToEvent.push({ callback: callback, emitter: eventEmitter }); eventEmitter.addEventListener(eventName, callback, useCapture); } /** * A mixin, providing event listening capabilities to an object. This is an inversion-of-control with regards to regular event listening; the listener maintains a list of the events it is listening to. This allows the listener to remove some or all its event listeners, for instance when it is disabled or destroyed. This is an easy way to avoid leaking listeners. Caveat: don't mix eventEmitter.removeEventListener and eventListener.stopListening throughout a project, as that could result in memory leaks. * @mixin * @alias bff/event-listener */ var eventListener = { /** * Start listening to an event on a specified event emitting object. Both eventEmitters and eventNames arguments can be arrays. The total amount of listeners added will be the Cartesian product of the two lists. * @instance * @arg {Object|Array|NodeList} eventEmitters - One or more event emitters that will be listened to. * @arg {string|Array} eventNames - One or more string identifiers for events that will be listented to. * @arg {function} callback - The function that will be called when the event is emitted. * @arg {any} [context] - The context with which the callback will be called (i.e. what &quot;this&quot; will be). * Will default to the caller of .listenTo, if not provided. */ listenTo: function (eventEmitters, eventNames, callback, context, useCapture) { if (RUNTIME_CHECKS) { if (!eventEmitters || !(eventEmitters.addEventListener || eventEmitters instanceof Array)) { throw '&quot;eventEmitters&quot; argument must be an event emitter or an array of event emitters'; } if (typeof eventNames !== 'string' &amp;&amp; !(eventNames instanceof Array)) { throw '&quot;eventNames&quot; argument must be a string or an array of strings'; } if (typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; } if (arguments.length &gt; 4 &amp;&amp; typeof useCapture !== 'boolean') { throw '&quot;useCapture&quot; argument must be a boolean value'; } } // Convenience functionality that allows you to listen to all items in an Array or NodeList // BFF Lists have this kind of functionality built it, so don't handle that case here eventEmitters = eventEmitters instanceof Array || (typeof NodeList !== 'undefined' &amp;&amp; eventEmitters instanceof NodeList) ? eventEmitters : [ eventEmitters ]; eventNames = eventNames instanceof Array ? eventNames : [ eventNames ]; for (var i = 0; i &lt; eventEmitters.length; ++i) { for (var j = 0; j &lt; eventNames.length; ++j) { setupListeners(this, eventEmitters[i], eventNames[j], callback, context, !!useCapture); } } }, /** * Stop listening to events. If no arguments are provided, the listener removes all its event listeners. Providing any or both of the optional arguments will filter the list of event listeners removed. * @instance * @arg {Object} [eventEmitter] - If provided, only callbacks attached to the given event emitter will be removed. * @arg {string} [eventName] - If provided, only callbacks attached to the given event name will be removed. */ stopListening: function (eventEmitter, eventName) { if (RUNTIME_CHECKS) { if (!!eventEmitter &amp;&amp; !eventEmitter.addEventListener) { throw '&quot;eventEmitter&quot; argument must be an event emitter'; } if (arguments.length &gt; 1 &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } } if (!this.__private || !this.__private.listeningTo) { return; } // Not listening to anything? We are done. var eventNames = eventName ? {} : this.__private.listeningTo; eventName &amp;&amp; (eventNames[eventName] = true); for (eventName in eventNames) { var listeningToList = this.__private.listeningTo[eventName]; if (!listeningToList) { continue; } filterList(listeningToList, eventName, eventEmitter); listeningToList.length || (delete this.__private.listeningTo[eventName]); } }, }; return eventListener; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.eventListener = moduleFactory(); } }()); × Search results Close "},"extend.js.html":{"id":"extend.js.html","title":"Source: extend.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Source: extend.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; /** * @module bff/extend */ function moduleFactory() { var TYPES = [ 'object', 'array', 'function', 'string', 'number', 'boolean', 'null', 'undefined' ]; var SOLVERS; function getType(item) { return item === null ? 'null' : item instanceof Array ? 'array' : typeof item; } function getSolverFunction(val) { return getType(val) === 'function' ? val : SOLVERS[val]; } /** * @callback module:bff/extend~conflictSolver * @param {Object} target * @param {Object} source * @param {string} prop - The name of the conflicting property. * @param {string|module:bff/extend~conflictSolver|Object} onConflict - The same onConflict argumet passed to the extend() call. * @param {string|module:bff/extend~conflictSolver} defaultOnConflict - The same defaultOnConfluct argumet passed to the extend() call. */ /** * A function that extends a target object with the properties of a source object, with options for describing property collision behavior. Note that the target object is mutated and returned, i.e. no new object gets created by invoking this function. * * The function comes with a set of named built-in conflict-solving functions: * * _crash_: Throws an error when a property conflict occurs. This is the default solver function. * * _useTarget_: Uses the target's property, i.e. leaves the target property unchanged. * * _useSource_: Uses the source's property, i.e. overwrites the target property with the source property. * * _merge_: Tries to merge the values in an intuitive way. * * Objects are merged recursively. * * Arrays are concatenated. * * Functions are combined, so that the target's function is first called, then the source's. Both functions are passed the same arguments. * * Numbers and strings added using the + operator. * * Boolean values are or:ed using the || operator (i.e. Boolean addition). * * If the source and target types are not the same, use the source value. * The caller also has the option to specify custom solver functions. * * **Examples** * ```javascript * extend( * { a: { b: 'b', c: 'c' } }, * { a: { c: 'c', d: 'd' } }, * 'useSource'); * // Returns { a: { c: 'c', d: 'd' } } * ``` * As can be seen in above, the 'useSource' conflict solver is not recursive, it simply overwrites any property it encounters. This is how e.g. jQuery.extend and _.assign behaves. * ```javascript * extend( * { a: { b: 'b', c: 'c' } }, * { a: { c: 'c', d: 'd' } }, * 'merge'); * // Returns { a: { b: 'b', c: 'c', d: 'd' } } * ``` * Here we see that the 'merge' solver works recursively. * ```javascript * extend( * { a: { b: 'b' }, num: 1 }, * { a: { c: 'c' }, num: 2 }, * { object: 'merge' }, 'useSource'); * // Returns { a: { b: 'b', c: 'c' }, num: 2 } * ``` * The above example uses the 'merge' solver on objects and the 'useSource' solver on all other property types. This produces a recursive behavior over objects, which is quite often desired. This is how e.g. _.merge behaves * ```javascript * extend( * { a: { b: 'b' }, num: 1 }, * { a: { c: 'c' }, num: 2, newProp: 3 }, * function (target, source, prop) { target[prop] = 42; }); * // Returns { a: 42, num: 42, newProp: 3 } * ``` * Above we see a (fairly useless) custom conflict solver function. * @alias module:bff/extend * @arg {Object} target - The object that will be extende with new properties. * @arg {Object} source - The object that provides the new properties. * @arg {string|module:bff/extend~conflictSolver|Object} [onConflict] - Specifies how to handle cases where a property exists both on the target and on the source. * * a _string_ argument will be used to identify one of the built in solver functions. Valid values are 'useTarget', 'useSouce', 'crash' and 'merge'. * * a _function_ argument will be used as-is as a solver for all conflicts. * * an _Object_ argument should have keys that correspond to value types, i.e. 'object', 'array', 'function', 'string', 'number', 'boolean', 'null' or 'undefined'. The object values can be either strings or functions, which will be used as solver functions for the corresponding key value types. * @arg {string|module:bff/extend~conflictSolver} [defaultOnConflict] - Specifies a default solver, in the same manner as the onConflict argument. Can only be used if onConflict is an object. * @returns {Object} The extended object */ function extend(target, source, onConflict, defaultOnConflict) { if (RUNTIME_CHECKS) { if (typeof target !== 'object') { throw '&quot;target&quot; argument must be an object'; } if (typeof source !== 'object') { throw '&quot;source&quot; argument must be an object'; } if (arguments.length &gt; 2 &amp;&amp; [ 'object', 'function', 'string' ].indexOf(typeof onConflict) === -1) { throw '&quot;onConflict&quot; argument must be an string (' + Object.keys(SOLVERS).join(', ') + '), object or function'; } if (arguments.length &gt; 3) { if (typeof onConflict !== 'object') { throw 'There is no point in specifying a defaultOnConflict of onConflict is not an object'; } if ([ 'function', 'string' ].indexOf(typeof defaultOnConflict) === -1) { throw '&quot;defaultOnConflict&quot; argument must be a string (' + Object.keys(SOLVERS).join(', ') + '), or function'; } } } var isOnConflictObject = getType(onConflict) === 'object'; defaultOnConflict = getSolverFunction(isOnConflictObject ? defaultOnConflict : onConflict) || SOLVERS.crash; isOnConflictObject || (onConflict = {}); var solverFunctions = {}; TYPES.forEach(function (type) { solverFunctions[type] = getSolverFunction(onConflict[type]) || defaultOnConflict; }); for (var prop in source) { if (target.hasOwnProperty(prop)) { solverFunctions[getType(target[prop])](target, source, prop, onConflict, defaultOnConflict); } else { target[prop] = source[prop]; } } return target; } SOLVERS = { useTarget: function useTarget() { // Don't do nothin }, useSource: function useSource(target, source, prop) { target[prop] = source[prop]; }, crash: function crash(target, source, prop) { throw 'Extend target already has property ' + prop; }, merge: function merge(target, source, prop, onConflict, defaultOnConflict) { var sourceProp = source[prop]; var sourcePropType = getType(sourceProp); var targetProp = target[prop]; var targetPropType = getType(targetProp); if (targetPropType !== sourcePropType) { target[prop] = source[prop]; return; } switch (targetPropType) { case 'object': extend(targetProp, sourceProp, onConflict, defaultOnConflict); break; case 'array': target[prop] = targetProp.concat(sourceProp); break; case 'function': target[prop] = function () { targetProp.apply(this, arguments); sourceProp.apply(this, arguments); }; break; case 'string': case 'number': target[prop] = targetProp + sourceProp; break; case 'boolean': // Logical 'or' is kind of like the Boolean version of addition target[prop] = targetProp || sourceProp; break; default: // Don't to nothin for e.g. 'null' and 'undefined' break; } }, }; return extend; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.extend = moduleFactory(); } }()); × Search results Close "},"list.js.html":{"id":"list.js.html","title":"Source: list.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Source: list.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; /** * Maintains a list of items. The idea is to stay as true as possible to the native Array interface, but to augment its usefulness by triggering events whenever the list is updated, as well as adding convenience functions for mutating the List in place. * * The exported List constructor can be used as-is, in which case a generic List will be created. This is a quite common use case. Alternatively, a List &quot;subclass&quot; constructor can be created by calling `List.withProperties(...)`. This second approach provides the possibility to add custom _calculated_ properties to the list. See {@link module:bff/list#withProperties} for more details. * * @exports bff/list */ function moduleFactory(extend, eventEmitter, Record) { var ADDED_EVENT = 'added'; var REPLACED_EVENT = 'replaced'; var REMOVED_EVENT = 'removed'; /** * @event module:bff/list#item:added * @arg {any} item - The item that was added to the List. * @arg {number} index - The position withing the List where the item was added. * @arg {module:bff/list} list - The List to which the item was added. */ var ITEM_ADDED_EVENT = 'item:added'; /** * @event module:bff/list#item:replaced * @arg {any} newItem - The item that was added to the List. * @arg {any} oldItem - The item that was removed from the List. * @arg {number} index - The position withing the List where the item was replaced. * @arg {module:bff/list} list - The List in which the item was replaced. */ var ITEM_REPLACED_EVENT = 'item:replaced'; /** * @event module:bff/list#item:removed * @arg {any} item - The item that was removed from the List. * @arg {number} index - The position withing the List where the item was removed. * @arg {module:bff/list} list - The List from which the item was removed. */ var ITEM_REMOVED_EVENT = 'item:removed'; /** * @event module:bff/list#change:length * @arg {number} newLength - The current length of the List. * @arg {number} oldLength - The previous length of the List. * @arg {module:bff/list} list - The List whose length has changed. */ var CHANGE_LENGTH_EVENT = 'change:length'; // &quot;Private event&quot; var PRECHANGE_LENGTH_EVENT = 'prechange:length'; var PRECHANGE_EVENT = 'prechange'; var CHANGE_EVENT = 'change'; /** * @callback module:bff/list~forEachCallback * @param {any} item - Current List item. * @param {number} index - Item position in List. * @param {module:bff/list} list - List being iterated over. */ /** * @callback module:bff/list~mapCallback * @param {any} item - Current List item. * @param {number} index - Item position in List. * @param {module:bff/list} list - List being iterated over. * @returns {any} Transformed object. */ /** * @callback module:bff/list~predicateCallback * @param {any} item - Current List item. * @param {number} index - Item position in List. * @param {module:bff/list} list - List being iterated over. * @returns {boolean} true if the item passes the test, false otherwise */ /** * @callback module:bff/list~reduceCallback * @param {any} previousItem - The value previously returned in the last invocation of the callback, or initialValue, if supplied. Usually an aggregate of previous items. * @param {any} item - Current List item being processed. * @param {number} index - Item position in List. * @param {module:bff/list} list - List being iterated over. * @returns {any} The aggregated value. */ /** * Compares _itemA_ and _itemB_ arguments according to some sorting criterion. Should return -1 if _itemA_ comes before _itemB_, 0 if _itemA_ is equal to _itemB_, 1 if _itemB_ comes before _itemA_. * @callback module:bff/list~compareFunction * @param {any} itemA - A list item. * @param {any} itemB - Another list item. * @returns {number}. */ var ITEM_EVENT_TOKEN_MATCHER = /item:/; function isEmitter(obj) { return !!(obj &amp;&amp; obj.addEventListener); } // Quack! function reemitItemEvent(self, item, strippedEventName, eventName) { self.listenTo(item, strippedEventName, function reemitItemEvent() { self.emitArgsAsArray(eventName, arguments); }); } function onItemAdded(self, item, index) { if (!isEmitter(item)) { self.emit(ITEM_ADDED_EVENT, item, index, self); return; } for (var eventName in self.__private.reEmittingEvents) { var strippedEventName = eventName.replace(ITEM_EVENT_TOKEN_MATCHER, ''); reemitItemEvent(self, item, strippedEventName, eventName); } item.emit(ADDED_EVENT, item, index, self); } function onItemRemoved(self, item, index) { if (!isEmitter(item)) { self.emit(ITEM_REMOVED_EVENT, item, index, self); return; } item.emit(REMOVED_EVENT, item, index, self); self.stopListening(item); } function onItemReplaced(self, newItem, oldItem, index) { if (newItem === oldItem) { return; } isEmitter(oldItem) ? oldItem.emit(REPLACED_EVENT, newItem, oldItem, index, self) : self.emit(ITEM_REPLACED_EVENT, newItem, oldItem, index, self); } function makeSetter(index) { // TODO: Investigate if this is really a good idea, performance wise return function setter(val) { this.splice(index, 1, val); }; } function makeGetter(index) { return function getter() { return this.__private.array[index]; }; } function delegate(funcName) { return function () { return this.__private.array[funcName].apply(this.__private.array, arguments); }; } function delegateCreator(funcName) { return function () { return new this.constructor(this.__private.array[funcName].apply(this.__private.array, arguments)); }; } function triggerPrechangeLengthEvent(self) { self.emit(PRECHANGE_EVENT, 'length', self.length, self); self.emit(PRECHANGE_LENGTH_EVENT, self.length, self); } function triggerChangeLengthEvent(self, prevLength) { if (self.length === prevLength) { return; } self.emit(CHANGE_EVENT, 'length', self.length, prevLength, self); self.emit(CHANGE_LENGTH_EVENT, self.length, prevLength, self); } /** * @alias module:bff/list */ var listFunctions = {}; /** * Add one or more items to the end of the List. Mirrors Array.push behavior. * @instance * @arg {...any} item - Each item argument will be pushed onto the List. * @emits module:bff/list#change:length * @emits module:bff/list#item:added * @returns {number} Updated List length */ listFunctions.push = function () { var nItems = arguments.length; if (nItems === 0) { return this.length; } var prevLength = this.length; triggerPrechangeLengthEvent(this); var privArray = this.__private.array; privArray.push.apply(privArray, arguments); for (var i = prevLength; i &lt; privArray.length; ++i) { onItemAdded(this, privArray[i], i); } triggerChangeLengthEvent(this, prevLength); return this.length; }; /** * Add one or more items to the beginning of the List. Mirrors Array.unshift behavior. * @instance * @arg {...any} item - Each item argument will be pushed onto the List. * @emits module:bff/list#change:length * @emits module:bff/list#item:added * @returns {Number} Updated List length */ listFunctions.unshift = function () { var nItems = arguments.length; if (nItems === 0) { return this.length; } var prevLength = this.length; triggerPrechangeLengthEvent(this); var privArray = this.__private.array; privArray.unshift.apply(privArray, arguments); for (var i = 0; i &lt; nItems; ++i) { onItemAdded(this, privArray[i], i); } triggerChangeLengthEvent(this, prevLength); return this.length; }; /** * Remove and return one item from the end of the List. Mirrors Array.pop behavior. * @instance * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {any} Removed item */ listFunctions.pop = function () { if (this.length === 0) { return undefined; } var prevLength = this.length; triggerPrechangeLengthEvent(this); var privArray = this.__private.array; var poppedItem = privArray.pop.apply(privArray, arguments); onItemRemoved(this, poppedItem, this.length); triggerChangeLengthEvent(this, prevLength); return poppedItem; }; /** * Remove and return one item from the beginning of the List. Mirrors Array.shift behavior. * @instance * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {any} Removed item */ listFunctions.shift = function () { if (this.length === 0) { return undefined; } var prevLength = this.length; triggerPrechangeLengthEvent(this); var privArray = this.__private.array; var shiftedItem = privArray.shift.apply(privArray, arguments); onItemRemoved(this, shiftedItem, 0); triggerChangeLengthEvent(this, prevLength); return shiftedItem; }; /** * Changes the content of the List by removing existing items and/or adding new items. Mirrors Array.splice behavior. * @instance * @arg {number} start - Index at which to start changing the array. If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many items from the end. * @arg {number} nItemsToRemove - An integer indicating the number of old array items to remove. If nItemsToRemove is greater than the number of items left in the array starting at start, then all of the items through the end of the array will be deleted. * @arg {...any} [itemToAdd] - Item that will be added to the array, starting at the index specified in the first argument. * @emits module:bff/list#change:length * @emits module:bff/list#item:added * @emits module:bff/list#item:replaced * @emits module:bff/list#item:removed * @returns {any[]} Array of removed items */ listFunctions.splice = function (start, nItemsToRemove) { if (RUNTIME_CHECKS) { if (arguments.length &lt; 2) { throw '&quot;start&quot; and &quot;nItemsToRemove&quot; arguments are mandatory'; } if (typeof start !== 'number') { throw '&quot;start&quot; argument must be a number'; } if (typeof nItemsToRemove !== 'number') { throw '&quot;nItemsToRemove&quot; argument must be a number'; } } var i; var oldLength = this.length; if (start &lt; 0) { start = oldLength + start; } nItemsToRemove = Math.min(nItemsToRemove, oldLength - start); var nItemsToAdd = arguments.length - 2; var nItemsToReplace = Math.min(nItemsToAdd, nItemsToRemove); var nItemsAffected = Math.max(nItemsToAdd, nItemsToRemove); var prevLength = this.length; triggerPrechangeLengthEvent(this); var privArray = this.__private.array; var deletedItems = privArray.splice.apply(privArray, arguments); for (i = 0; i &lt; nItemsAffected; ++i) { if (i &lt; nItemsToAdd) { onItemAdded(this, privArray[start + i], start + i); } if (i &lt; nItemsToReplace) { onItemReplaced(this, privArray[start + i], deletedItems[i], start + i); } if (i &lt; nItemsToRemove) { onItemRemoved(this, deletedItems[i], start + i); } } triggerChangeLengthEvent(this, prevLength); return deletedItems; }; [ /** * Executes the given function once per List item. Mirrors Array.forEach behavior. * @func forEach * @instance * @arg {module:bff/list~forEachCallback} callback - The function that will be called once per List item. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. */ 'forEach', /** * Mirrors Array.every behavior. * @func every * @instance * @arg {module:bff/list~predicateCallback} predicate - Executed once per List item. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. * @returns {boolean} true if all items passes the predicate test, false otherwise. */ 'every', /** * Mirrors Array.some behavior. * @func some * @instance * @arg {module:bff/list~predicateCallback} predicate - Executed once per List item. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. * @returns {boolean} true if at least one item passes the predicate test, false otherwise. */ 'some', /** * Mirrors Array.indexOf behavior. * @func indexOf * @instance * @arg {any} searchItem - The item to locate within the List. * @arg {number} [fromIndex] - The index to start the search at. If the index is greater than or equal to the List's length, -1 is returned, which means the List will not be searched. If the provided index value is a negative number, it is taken as the offset from the end of the List. * @returns {number} The first index at which a given item can be found in the List, or -1 if it is not present. */ 'indexOf', /** * @func lastIndexOf * @instance * @arg {any} searchItem - The item to locate within the List. * @arg {number} [fromIndex] - The index at which to start searching backwards. Defaults to the List's length minus one, i.e. the whole List will be searched. If the index is greater than or equal to the length of the List, the whole List will be searched. If negative, it is taken as the offset from the end of the List. Mirrors Array.lastIndexOf behavior. * @returns {number} The last index at which a given item can be found in the List, or -1 if it is not present. */ 'lastIndexOf', /** * @func join * @instance * @arg {string} [separator] - Specifies a string to separate each item of the List. If omitted, the List items are separated with a comma. Mirrors Array.join behavior. * @returns {string} The stringified List items, joined by the 'separator' string argument. */ 'join', /** * Applies a function against an accumulator and each value of the List (from left-to-right) to reduce it to a single value. Mirrors Array.reduce behavior. * @func reduce * @instance * @arg {module:bff/list~reduceCallback} callback - The function that will be called once per List item. * @arg {any} initialValue - Value to use as the first argument to the first call of the callback. * @returns {any} Aggregated value */ 'reduce', /** * Applies a function against an accumulator and each value of the List (from right-to-left) to reduce it to a single value. Mirrors Array.reduceRight behavior. * @func reduceRight * @instance * @arg {module:bff/list~reduceCallback} callback - The function that will be called once per List item. * @arg {any} initialValue - Value to use as the first argument to the first call of the callback. * @returns {any} Aggregated value */ 'reduceRight' ].forEach(function (funcName) { listFunctions[funcName] = Array.prototype[funcName]; }); [ /** * Sorts the items of the List in place. The sort is not necessarily stable. The default sort order is according to string Unicode code points, unless a custom comparator finction is provided. Mirrors the behavior of Array.sort. No events are emitted by this operation. * @func sort * @instance * @arg {module:bff/list~compareFunction} [comparator] - A function that specifies the ordering of two arbitrary List items. Called multiple times in order to produce a total ordering of the items. * @returns {List} The sorted list. */ 'sort', /** * Reverses the List in place. Mirros the behavior of Array.reverse. No events are emitted by this operation. * @func reverse * @instance */ 'reverse' ].forEach(function (funcName) { listFunctions[funcName] = delegate(funcName); }); [ /** * Creates a new List with all items that pass the test implemented by the predicate function test. The original list is unchanged. Mirrors the behavior of Array.filter. * @func filter * @instance * @arg {module:bff/list~predicateCallback} predicate - Executed once per List item. * @returns {List} The new List. */ 'filter', /** * Creates a new List from the range of current items specified by the begin and end arguments. Mirrors the behavior of Array.slice. * @func slice * @instance * @arg {number} [begin] Index that specifies the beginning of the range. Inclusive. A negative index will * be relative to the end of the List instead of the beginning. * @arg {number} [end] Index that specifies the end of the range. Exclusive. A negative index will * be relative to the end of the List instead of the beginning. * @returns {List} The new List. */ 'slice', /** * Creates a new List with the results of calling a provided callback function on every element in the List. Mirrors the behavior of Array.map. * @func map * @instance * @arg {module:bff/module~mapCallback} callback - Executed once per List item. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. * @returns {List} The new List. */ 'map' ].forEach(function (funcName) { listFunctions[funcName] = delegateCreator(funcName); }); /** * Returns a new List comprised of the List on which it is called joined with the List(s), Array(s) and/or value(s) provided as arguments. Mirrors the behavior of Array.concat. * @instance * @arg {...any} value - A List, Array or value that will be concatenated with the original List. Lists and Arrays will be deconstructed and each item added to the new List. * @returns {List} The new List. */ listFunctions.concat = function () { for (var i = 0, n = arguments.length; i &lt; n; ++i) { var argument = arguments[i]; if (!(argument instanceof Array) &amp;&amp; argument.length !== undefined) { arguments[i] = argument.toArray(); } } return new this.constructor(this.__private.array.concat.apply(this.__private.array, arguments)); }; /** * Mutates the List by removing all items that does not pass the predicate function test. * @instance * @arg {module:bff/list~predicateCallback} predicate - Called once per List item to determine whether the item should be removed. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing predicate callback. * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {List} The filtered List. */ listFunctions.filterMut = function (predicate, thisArg) { if (RUNTIME_CHECKS) { if (typeof predicate !== 'function') { throw '&quot;predicate&quot; argument must be a function'; } } var removeCount = 0; for (var i = this.length - 1; i &gt;= -1; --i) { if (i &gt; -1 &amp;&amp; !predicate.call(thisArg, this[i], i, this)) { removeCount++; } else if (removeCount) { this.splice(i + 1, removeCount); removeCount = 0; } } return this; }; /** * Mutates the List by removing all occurances of the provided item. * @instance * @arg {any} item - The item to remove from the list. * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {List} The List, without any occurances of 'item'. */ listFunctions.remove = function (item) { return this.filterMut(function (listItem) { return item !== listItem; }); }; /** * Mutates the List by removing all items. * @instance * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {List} The List, now empty. */ listFunctions.clear = function () { return this.splice(0, this.length); }; /** * Mutates the List by adding the items comprising the provided List or Array to the end of the List. * @instance * @arg {module:bff/list|Array} items - The items that will be appended to the List. * @emits module:bff/list#change:length * @emits module:bff/list#item:added * @returns {List} The List, with new items appended. */ listFunctions.pushAll = function (items) { if (RUNTIME_CHECKS &amp;&amp; (!items || items.length === undefined)) { throw '&quot;items&quot; argument must have a length property'; } items.length &amp;&amp; this.push.apply(this, items); return this.length; }; /** * Mutates the List by removing all elements outside of range specified by the begin and end arguments. * @instance * @arg {number} [begin] Index that specifies the beginning of the range. Inclusive. A negative index will be relative to the end of the List instead of the beginning. * @arg {number} [end] Index that specifies the end of the range. Exclusive. A negative index will be relative to the end of the List instead of the beginning. * @emits module:bff/list#change:length * @emits module:bff/list#item:removed * @returns {List} The List, sans the items outside of the specified range. */ listFunctions.sliceMut = function (begin, end) { if (RUNTIME_CHECKS) { if (arguments.length &lt; 2) { throw '&quot;begin&quot; and &quot;end&quot; arguments are mandatory'; } if (typeof begin !== 'number') { throw '&quot;begin&quot; argument must be a number'; } if (typeof end !== 'number') { throw '&quot;end&quot; argument must be a number'; } } var length = this.length; end = (typeof end !== 'undefined') ? end : length; // Handle negative value for &quot;begin&quot; var start = begin || 0; start = (start &gt;= 0) ? start : Math.max(0, length + start); // Handle negative value for &quot;end&quot; var upTo = ((typeof end === 'number') ? Math.min(end, length) : length) - 1; end &lt; 0 &amp;&amp; (upTo = length + end); // Actual expected size of the slice var size = upTo - start; if (size !== length) { this.splice(0, start); this.splice(upTo, length - upTo); } return this; }; /** * Replaces all items in the List with new items, generated by the callback function. * @instance * @arg {module:bff/module~mapCallback} callback - Executed once per List item to produce new items. * @arg {any} [thisArg] - Value to use as &quot;this&quot; when executing callback. * @emits module:bff/list#item:replaced * @returns {List} The List, with all items updated. */ listFunctions.mapMut = function (callback, thisArg) { if (RUNTIME_CHECKS &amp;&amp; typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; } for (var i = 0, length = this.length; i &lt; length; ++i) { this[i] = callback.call(thisArg, this[i], i, this); } return this; }; /** * Returns the first item in the List that passes the predicate function test, or undefined if no item passes. * @instance * @arg {module:bff/list~predicateCallback} predicate - Called once per List item to in order to find a matching item. * @returns {any|undefined} The matching item, if any. */ listFunctions.find = function (predicate, thisArg) { if (RUNTIME_CHECKS &amp;&amp; typeof predicate !== 'function') { throw '&quot;predicate&quot; argument must be a function'; } for (var i = 0, length = this.length; i &lt; length; ++i) { if (predicate.call(thisArg, this[i], i, this)) { return this[i]; } } }; /** * Returns the index of the first item in the List that passes the predicate function test, or -1 if no item passes. * @instance * @arg {module:bff/list~predicateCallback} predicate - Called once per List item to in order to find a matching item. * @returns {number} The position of the matching item, or -1 if none matches. */ listFunctions.findIndex = function (predicate, thisArg) { if (RUNTIME_CHECKS &amp;&amp; typeof predicate !== 'function') { throw '&quot;predicate&quot; argument must be a function'; } for (var i = 0, length = this.length; i &lt; length; ++i) { if (predicate.call(thisArg, this[i], i, this)) { return i; } } return -1; }; /** * Returns whether the provided item is part of the List. * @instance * @arg {any} item * @arg {number} [fromIndex] - The index to start the search at. If the index is greater than or equal to the List's length, -1 is returned, which means the List will not be searched. If the provided index value is a negative number, it is taken as the offset from the end of the List. * @returns {boolean} True if the item is part of the List, false otherwise. */ listFunctions.includes = function (item, fromIndex) { if (RUNTIME_CHECKS &amp;&amp; arguments.length &gt; 1 &amp;&amp; typeof fromIndex !== 'number') { throw '&quot;fromIndex&quot; number must be a number'; } fromIndex = fromIndex || 0; var index = this.__private.array.indexOf(item); return index !== -1 &amp;&amp; index &gt;= fromIndex; }; /** * Returns an newly created Array, containing all the items of the List. List properties are not copied to the Array object. The items are copied shallowly. * @instance * @returns {Array} */ listFunctions.toArray = function () { return this.__private.array.slice(); }; /** * Returns a newly created Array representation of the List, containing deep copies of all the List's items, but not its properties. * @instance * @returns {Array} */ listFunctions.toJSON = function () { var jsonObj = new Array(this.length); for (var i = 0, n = jsonObj.length; i &lt; n; ++i) { var item = this[i]; jsonObj[i] = item instanceof Object ? (item.toJSON ? item.toJSON() : JSON.parse(JSON.stringify(item))) : item; } return jsonObj; }; /** * Returns a newly created Object containing the List's deep copied properties. * @instance * @returns {Object} */ listFunctions.propertiesToJSON = function () { return Record.prototype.toJSON.call(this); }; /** * Augmented version of {@link bff/event-emitter#addEventListener} that provides the option to listen to events emitted from any item in the List. To add a listener to an item event, prepend the event name with 'item:'. For instance, to listen for the 'change' event on all the list items (even ones added after the listener was created), add a listener for the 'item:change' event. * @instance * @arg {string} - Identifier string for the event. */ listFunctions.addEventListener = function (eventName) { if (RUNTIME_CHECKS &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (!ITEM_EVENT_TOKEN_MATCHER.test(eventName) || this.__private.reEmittingEvents[eventName]) { return; } this.__private.reEmittingEvents[eventName] = true; var strippedEventName = eventName.replace(ITEM_EVENT_TOKEN_MATCHER, ''); for (var i = 0, n = this.length; i &lt; n; ++i) { var item = this[i]; isEmitter(item) &amp;&amp; reemitItemEvent(this, item, strippedEventName, eventName); } }; /** * Augmented version of {@link bff/event-emitter#removeEventListener} that provides functionality for removing &quot;item&quot; event listeners, e.g. for stop listening to events like &quot;items:change&quot;. * @instance * @arg {string} - Identifier string for the event. */ listFunctions.removeEventListener = function (eventName) { if (RUNTIME_CHECKS &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (!ITEM_EVENT_TOKEN_MATCHER.test(eventName)) { return; } // Check if we still need to re-emit this event var listeners = this.__private.listeners[eventName]; if (listeners &amp;&amp; listeners.length) { return; } delete this.__private.reEmittingEvents[eventName]; var strippedEventName = eventName.replace(ITEM_EVENT_TOKEN_MATCHER, ''); this.stopListening(undefined, strippedEventName); }; extend(listFunctions, eventEmitter, { 'function': 'merge' }); /** * @instance * @returns {string} A human readable string representation of the List. */ listFunctions.toString = function () { return JSON.stringify(this, undefined, 2); }; function withProperties(schema) { for (var propName in schema) { var propertySchema = schema[propName]; if (RUNTIME_CHECKS &amp;&amp; !propertySchema.getter) { throw 'List property ' + propName + ' must have a custom getter function'; } if (RUNTIME_CHECKS &amp;&amp; propertySchema.setter) { throw 'List property ' + propName + ' may not have a setter'; } propertySchema.setter = false; } extend(schema, { length: { getter: function () { return this.__private.array.length; }, setter: false, }, first: { getter: function () { return this[0]; }, setter: false, }, last: { getter: function () { return this[this.length - 1]; }, setter: false, } }); var RecordSubclass = Record.withProperties(schema, true); function List(items) { if (RUNTIME_CHECKS &amp;&amp; arguments.length &gt; 0 &amp;&amp; (!items || items.length === undefined)) { throw '&quot;items&quot; argument must have a length property'; } this.__private || Object.defineProperty(this, '__private', { writable: true, value: {}, }); this.__private.array = []; this.__private.reEmittingEvents = {}; this.listenTo(this, CHANGE_LENGTH_EVENT, function (length, prevLength) { var diff = length - prevLength; var i; if (diff &gt; 0) { for (i = prevLength; i &lt; length; ++i) { Object.defineProperty(this, i, { enumerable: true, configurable: true, get: makeGetter(i), set: makeSetter(i), }); } } else { for (i = length; i &lt; prevLength; ++i) { delete this[i]; } } }); // We don't want to send any arguments to the record constructor, // none of the properties we added has any setters! RecordSubclass.call(this); items = items || []; items.length &amp;&amp; this.pushAll(items); } List.prototype = Object.create(RecordSubclass.prototype); List.prototype.constructor = List; extend(List.prototype, listFunctions); return List; } /** * Creates a new List, with an optional list or array of initial items. * @constructor * @alias module:bff/list * @mixes bff/event-emitter * @mixes bff/event-listener * @arg {(Array|List)} [items] - Items that will be added to the List on creation. */ var List = withProperties({}); /** * Creates a new List constructor function, that will create List instances with the property schema * provided to this function * @func * @static * @arg {Object} schema - An object describing the properties that will be part of all new instances created by the returned constructor function. The property descriptions should be on the same format at the schema specified for {@link module:bff/record.withProperties}, with the only exception that setters are not allowed. * @returns {function} New constructor function based on the provided schema. */ List.withProperties = withProperties; return List; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([ './extend', './event-emitter', './record' ], moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(require('./extend'), require('./event-emitter'), require('./record')); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.List = moduleFactory(bff.extend, bff.eventEmitter, bff.Record); } }()); × Search results Close "},"patch-dom.js.html":{"id":"patch-dom.js.html","title":"Source: patch-dom.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Source: patch-dom.js /* global define */ (function () { 'use strict'; /** * @module bff/patch-dom */ function moduleFactory() { function makeLevMat(xSize, ySize) { var i, levMat = new Array(xSize + 1); for (i = 0; i &lt;= xSize; ++i) { levMat[i] = new Array(ySize + 1); levMat[i][0] = i; } for (i = 0; i &lt;= ySize; ++i) { levMat[0][i] = i; } return levMat; } var preallocLevMatSizeX = 63; var preallocLevMatSizeY = 63; var preallocLevMat = makeLevMat(preallocLevMatSizeX, preallocLevMatSizeY); function areProbablyTheSame(target, source) { if (!source) { return false; } return target.nodeName === source.nodeName &amp;&amp; ((target.attributes &amp;&amp; target.getAttribute('data-id')) === (source.attributes &amp;&amp; source.getAttribute('data-id'))); } function namedNodeMapToObject(namedNodeMap) { var obj = {}; for (var i = 0, n = namedNodeMap.length; i &lt; n; ++i) { var node = namedNodeMap[i]; obj[node.name] = node.value; } return obj; } function patchElementNode(target, source) { // Ref: http://quirksmode.org/dom/core/#attributes var targetAttrObj = namedNodeMapToObject(target.attributes); var sourceAttrArr = source.attributes; var i, n, sourceAttr, targetAttr, attrName; // Special cases if (target.nodeName === 'INPUT') { target.value = source.value || ''; } if (source.checked !== undefined) { target.checked = source.checked; } if (source.selected !== undefined) { target.selected = source.selected; } for (i = 0, n = sourceAttrArr.length; i &lt; n; ++i) { sourceAttr = sourceAttrArr[i]; attrName = sourceAttr.name; targetAttr = targetAttrObj[attrName]; delete targetAttrObj[sourceAttr.name]; if (targetAttr &amp;&amp; targetAttr.value === sourceAttr.value) { continue; } target.setAttribute(attrName, sourceAttr.value); } for (attrName in targetAttrObj) { target.removeAttribute(attrName); } } function patchTextNode(target, source) { var sourceValue = source.nodeValue; if (target.nodeValue === sourceValue) { return; } target.nodeValue = sourceValue; } function patchNode(target, source) { switch (target.nodeType) { case Node.ELEMENT_NODE: patchElementNode(target, source); break; case Node.TEXT_NODE: patchTextNode(target, source); break; } } function shouldIgnoreNode(node) { return !!node.hasAttribute &amp;&amp; node.hasAttribute('patch-ignore'); } function patchRecursive(target, source, ignoreSubtreeOf) { var targetParent = target.parentNode; var childrenToPatch = []; // Patch the current node if (areProbablyTheSame(target, source)) { patchNode(target, source); } else { if (source) { targetParent.replaceChild(source, target); } else { targetParent.removeChild(target); } return; } if (ignoreSubtreeOf &amp;&amp; Array.prototype.indexOf.call(ignoreSubtreeOf, target) !== -1) { return; } // Diff subtree using Levenshtein distance algorithm var targetChildren = target.childNodes; var sourceChildren = source.childNodes; var i, n, targetPos, sourcePos, targetChild, sourceChild; var nTargetChildren = targetChildren.length; var nSourceChildren = sourceChildren.length; var nLeadingSameTypeChildren = 0; var nIgnoredTargetChildren = 0; var nTargetChildrenToIgnore = 0; var allChildrenMatchSoFar = true; for (i = 0; i &lt; nTargetChildren; ++i) { if (shouldIgnoreNode(targetChildren[i])) { nTargetChildrenToIgnore++; } else if (allChildrenMatchSoFar) { if (areProbablyTheSame(targetChildren[i + nTargetChildrenToIgnore], sourceChildren[i])) { childrenToPatch.push(targetChildren[i + nTargetChildrenToIgnore]); childrenToPatch.push(sourceChildren[i]); nLeadingSameTypeChildren++; } else { allChildrenMatchSoFar = false; } } } if (nTargetChildren - nTargetChildrenToIgnore === 0 &amp;&amp; nSourceChildren === 0) { return; } var levMatSizeX = nTargetChildren - nLeadingSameTypeChildren; var levMatSizeY = nSourceChildren - nLeadingSameTypeChildren; var levMat; if (preallocLevMatSizeX &lt; levMatSizeX || preallocLevMatSizeY &lt; levMatSizeY) { // The preallocated matrix is too small. if (preallocLevMatSizeX &lt;= levMatSizeX &amp;&amp; preallocLevMatSizeY &lt;= levMatSizeY) { // The needed matrix is bigger or equal to the preallocated one i all dimensions, so let's grow the // preallocated one. preallocLevMatSizeX = levMatSizeX; preallocLevMatSizeY = levMatSizeY; preallocLevMat = makeLevMat(preallocLevMatSizeX, preallocLevMatSizeY); levMat = preallocLevMat; } else { // The needed matrix is larger than the preallocated one in some, but not all dimensions. This // should be quite an edge case, so just use a temporary matrix for this operation. levMat = makeLevMat(levMatSizeX, levMatSizeY); } } else { // The needed matrix fits inside the preallocated one, so just use that one. This should be the most // common case. levMat = preallocLevMat; } for (targetPos = 1; targetPos + nIgnoredTargetChildren &lt;= nTargetChildren - nLeadingSameTypeChildren; targetPos++) { targetChild = targetChildren[targetPos + nIgnoredTargetChildren + nLeadingSameTypeChildren - 1]; if (shouldIgnoreNode(targetChild)) { nIgnoredTargetChildren++; targetPos--; continue; } for (sourcePos = 1; sourcePos &lt;= nSourceChildren - nLeadingSameTypeChildren; ++sourcePos) { if (areProbablyTheSame(targetChild, sourceChildren[sourcePos + nLeadingSameTypeChildren - 1])) { levMat[targetPos][sourcePos] = levMat[targetPos - 1][sourcePos - 1]; } else { levMat[targetPos][sourcePos] = 1 + Math.min( levMat[targetPos - 1][sourcePos - 1], levMat[targetPos][sourcePos - 1], levMat[targetPos - 1][sourcePos]); } } } targetPos = nTargetChildren - nLeadingSameTypeChildren - nTargetChildrenToIgnore; sourcePos = nSourceChildren - nLeadingSameTypeChildren; while (targetPos &gt; 0 || sourcePos &gt; 0) { targetChild = targetChildren[targetPos + nLeadingSameTypeChildren + nTargetChildrenToIgnore - 1]; if (targetChild &amp;&amp; shouldIgnoreNode(targetChild)) { nTargetChildrenToIgnore--; continue; } var substitution = targetPos &gt; 0 &amp;&amp; sourcePos &gt; 0 ? levMat[targetPos - 1][sourcePos - 1] : Infinity; var insertion = sourcePos &gt; 0 ? levMat[targetPos][sourcePos - 1] : Infinity; var deletion = targetPos &gt; 0 ? levMat[targetPos - 1][sourcePos] : Infinity; sourceChild = sourceChildren[sourcePos + nLeadingSameTypeChildren - 1]; if (substitution &lt;= insertion &amp;&amp; substitution &lt;= deletion) { if (substitution &lt; levMat[targetPos][sourcePos]) { // Substitute target.replaceChild(sourceChild, targetChild); } else { // Add to patch list childrenToPatch.push(targetChild); childrenToPatch.push(sourceChild); } targetPos--; sourcePos--; } else if (insertion &lt;= deletion) { // Insert target.insertBefore(sourceChild, targetChild ? targetChild.nextSibling : null); sourcePos--; } else { // Delete target.removeChild(targetChild); targetPos--; } } for (i = 0, n = childrenToPatch.length; i &lt; n; i += 2) { patchRecursive(childrenToPatch[i], childrenToPatch[i + 1], ignoreSubtreeOf); } } /** * Patches the target element and its child elements such that it will be identical to the source element and its child structure. It achieves this by recursively _patching_, _removing_ or _adding_ elements in the target element hierarchy. The overall logic of the algorithm goes as follows: * * If the target and source elements have differing node type types (e.g. a `&lt;div&gt;` and a `&lt;span&gt;` tag) the target element is replaced by the source element. * * Otherwise, if the target and source elements are of the same type (e.g. two `&lt;div&gt;` tags), the attributes of the target element will be replaced by those of the target element. Then the target and source elements' children lists are compared using a version of the Levenshtein algorithm. This results in the children of the target element being either patched (by calling `patchDom` recursively) or removed. Child elements only present in the source child list will also be added to the target child list at their respective positions. * * If any encountered target elements has a `patch-ignore` attribute, that node and its children will not be patched. * * @alias module:bff/patch-dom * @arg {HTMLElement} target - The element (hierarchy) to be patched. Will be identical to the source element (hierarchy) after the function call completes. * @arg {HTMLElement} source - The element (hierarchy) that the target (hierarchy) will be transformed into. * @arg {Object} [options] - Options that will be recursively passed down to all patchDom calls. Currently only one option is implemented: * * _ignoreSubtreeOf_: A CSS selector string that identifies any elements, whose subtrees will not be patched. */ function patchDom(target, source, options) { options = options || {}; if (RUNTIME_CHECKS) { if (!(target instanceof HTMLElement)) { throw '&quot;target&quot; argument must be an HTMLElement'; } else if (!(source instanceof HTMLElement)) { throw '&quot;source&quot; argument must be an HTMLElement'; } else if (arguments.length &gt; 2 &amp;&amp; typeof options !== 'object') { throw '&quot;options&quot; argument must be an object'; } else if ('ignoreSubtreeOf' in options &amp;&amp; typeof options.ignoreSubtreeOf !== 'string') { throw 'ignoreSubtreeOf option must be a valid CSS selector string'; } else if (target === source) { throw 'Target and source are the same, which makes no sense!'; } } var ignoreSubtreeOf = options.ignoreSubtreeOf &amp;&amp; target.querySelectorAll(options.ignoreSubtreeOf); patchRecursive(target, source, ignoreSubtreeOf); return target; } return patchDom; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define(moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.patchDom = moduleFactory(); } }()); × Search results Close "},"record.js.html":{"id":"record.js.html","title":"Source: record.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Source: record.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; /** * A [Record](https://en.wikipedia.org/wiki/Record_(computer_science) is the basic entity of the data layer. In difference to regular JS objects, it has a predefined set of properties. The properties are specified by &quot;subclassing&quot; the abstract Record constructor by calling `Record.withProperties(...)` and providing a properties schema. For more details, see {@link module:bff/record.withProperties}. * * The major advantages of using a predefined (i.e. known and finite) set of properties are: * * Each property gets a custom setter, that emits a change event whenever the property value changes. The setter can also do types checks on the assigned value (which it does in dev. mode). * * The record instances can be locked using Object.preventExtensions, with the nice effect that trying to assign a value to an undeclared property will throw an error. * * @exports bff/record */ function moduleFactory(extend, eventEmitter, eventListener) { /** * Emitted when the property with name _[property name]_ is about to be assigned a new value. This event is always emitted upon assignment, even is the value to be assigned is the same as the current value. * @event module:bff/record#prechange:[property name] * @arg {any} currentValue - The current property value * @arg {module:bff/record} self - The record that triggered the event */ /** * Emitted when some property value is about to be assigned a new value. This event is always emitted upon assignment, even is the value to be assigned is the same as the current value. * @event module:bff/record#prechange * @arg {string} propertyName - The name of the record property that is about to be assigned to * @arg {any} currentValue - The current property value * @arg {module:bff/record} self - The record that triggered the event */ var PRECHANGE_EVENT = 'prechange'; /** * Emitted when the value of the property with name _[property name]_ has changed. This event is only emitted if the assigned value actually differs from the previous one, compared using strict equality. * @event module:bff/record#change:[property name] * @arg {any} newValue - The new property value * @arg {any} oldValue - The previous property value * @arg {module:bff/record} self - The record that triggered the event */ /** * Emitted when some property value has changed. This event is only emitted if the assigned value actually differs from the previous one, compared using strict equality. * @event module:bff/record#change * @arg {string} propertyName - The name of the record property that has changed * @arg {any} newValue - The new property value * @arg {any} oldValue - The previous property value * @arg {module:bff/record} self - The record that triggered the event */ var CHANGE_EVENT = 'change'; var ANY_TYPE = typeof Symbol === 'undefined' ? Object.freeze({}) : Symbol('ANY_TYPE'); function isPlainishObject(val) { // Plain in this context means that it is an object that is not an array or a function return (val instanceof Object) &amp;&amp; val.constructor &amp;&amp; !Array.isArray(val) &amp;&amp; !val.call &amp;&amp; !val.apply; } function validateInput(val, propName, propSchema) { if (RUNTIME_CHECKS &amp;&amp; !('type' in propSchema)) { throw 'propSchema is missing a &quot;type&quot; property'; } var isValueOk = false; // JS type checking is very inconsistent because of how primitive/boxed types are handled. // Below we try create a consistent type checking scheme, where no distinction between // boxed (e.g. var a = new Number(3)) and primitive (e.g. var a = 3) are made. for (var i = 0, n = propSchema.type.length; i &lt; n; ++i) { var anOkType = propSchema.type[i]; if (anOkType === ANY_TYPE) { isValueOk = true; break; } else if (anOkType === undefined) { if (val === undefined) { isValueOk = true; break; } } else if (anOkType === null) { if (val === null) { isValueOk = true; break; } } else if (anOkType === String) { if (typeof val === 'string') { isValueOk = true; break; } } else if (anOkType === Number) { if (typeof val === 'number') { isValueOk = true; break; } } else if (anOkType === Boolean) { if (typeof val === 'boolean') { isValueOk = true; break; } } else if (val instanceof anOkType) { isValueOk = true; break; } } if (!isValueOk) { var typeNames = propSchema.type.map(function (val) { return val instanceof Function ? val.name : typeof val; }); throw 'Property ' + propName + ' must be of type [' + typeNames.join(', ') + '], it can not be assigned a value of type ' + (typeof val); } } function makeSetter(propName, propSchema) { var MY_PRECHANGE_EVENT = PRECHANGE_EVENT + ':' + propName; var MY_CHANGE_EVENT = CHANGE_EVENT + ':' + propName; // TODO: make two different setter functions (in outer scope) and select (+bind) // one of the depending of whether the propery has any dependers return function setter(val) { // If there is a custom setter, use it to transform the value propSchema.setter &amp;&amp; (val = propSchema.setter.call(this, val)); var oldVal = this[propName]; this.emit(PRECHANGE_EVENT, propName, oldVal, this); this.emit(MY_PRECHANGE_EVENT, oldVal, this); this.__private.values[propName] = val; // If the value change did not affect the public value, we don't trigger any change events if (this[propName] === oldVal) { return; } var newVal = this[propName]; this.emit(CHANGE_EVENT, propName, newVal, oldVal, this); this.emit(MY_CHANGE_EVENT, newVal, oldVal, this); // Input validation, after setters and getters has been applied RUNTIME_CHECKS &amp;&amp; validateInput(newVal, propName, propSchema); }; } function makeGetter(propName, propSchema) { return propSchema.getter ? function getter() { return propSchema.getter.call(this, this.__private.values[propName]); } : function getter() { return this.__private.values[propName]; }; } /** * Creates a new Record (subclass) with an optional set of initial values. * @alias module:bff/record * @constructor * @mixes bff/event-emitter * @mixes bff/event-listener * @arg {Object|module:bff/record} [values] - An object containing initial values for the Record to be created. */ function Record(values) { if (RUNTIME_CHECKS) { if (values !== undefined &amp;&amp; typeof values !== 'object') { throw '&quot;values&quot; argument must be an object'; } if (!this.__private) { throw 'Record is an abstract class, meant to be &quot;subclassed&quot; using Record.withProperties(schema)'; } } this.__private.values = {}; this.__private.previousValues = {}; var schema = this.__private.schema; var propsUnion = {}; var propSchema, i; for (var propName in schema) { propSchema = schema[propName]; var defaultValue = propSchema.defaultValue; // Allow default values to be generated by functions, unless the prop schema type is Function var propSchemaTypes = propSchema.type; if (defaultValue instanceof Function) { var canTypeBeFunction = false; for (i = 0; i &lt; propSchemaTypes.length; i++) { if (propSchemaTypes[i] === Function) { canTypeBeFunction = true; break; } } if (!canTypeBeFunction) { defaultValue = defaultValue(); } } propsUnion[propName] = defaultValue; } for (propName in values) { if (RUNTIME_CHECKS &amp;&amp; !schema.hasOwnProperty(propName)) { throw 'Cannot assign undeclared property ' + propName; } propsUnion[propName] = values[propName]; } // Silently assign initial values for (propName in propsUnion) { var val = propsUnion[propName]; schema[propName].setter &amp;&amp; (val = schema[propName].setter.call(this, val)); this.__private.values[propName] = val; RUNTIME_CHECKS &amp;&amp; validateInput(this[propName], propName, schema[propName]); } var onPreChangeEvent = function (propName) { var oldVal = this.__private.previousValues[propName] = this[propName]; this.emit(PRECHANGE_EVENT, propName, oldVal, this); this.emit(PRECHANGE_EVENT + ':' + propName, oldVal, this); }; var onChangeEvent = function (propName) { var oldVal = this.__private.previousValues[propName]; var newVal = this[propName]; // If the value change did not affect the public value, we don't trigger any change events if (newVal === oldVal) { return; } this.emit(CHANGE_EVENT, propName, newVal, oldVal, this); this.emit(CHANGE_EVENT + ':' + propName, newVal, oldVal, this); }; for (propName in schema) { propSchema = schema[propName]; if (!propSchema.dependencies) { continue; } for (i = 0; i &lt; propSchema.dependencies.length; ++i) { var dependencyPropName = propSchema.dependencies[i]; this.listenTo(this, PRECHANGE_EVENT + ':' + dependencyPropName, onPreChangeEvent.bind(this, propName)); this.listenTo(this, CHANGE_EVENT + ':' + dependencyPropName, onChangeEvent.bind(this, propName)); } } } /** * Returns a newly created Object containing the Records's deep copied properties. The fact that this function returns an Object and not a strin is a bit misleading, but this naming convension is used for conformity reasons, see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior} * @returns {Object} */ Record.prototype.toJSON = function () { var jsonObj = {}; for (var propName in this.__private.values) { var val = this[propName]; jsonObj[propName] = val instanceof Object ? (val.toJSON ? val.toJSON() : JSON.parse(JSON.stringify(val))) : val; } return jsonObj; }; /** * @returns {string} A human readable string representation of the Record. */ Record.prototype.toString = function () { return JSON.stringify(this, undefined, 2); }; extend(Record.prototype, eventEmitter); extend(Record.prototype, eventListener); /** * Creates a new Record constructor function, that will create Record instances with the property schema provided to this function. The various aspects of the property schema are described in detail below, but let's start with an example. * ```javascript * var Person = Record.withProperties({ * firstName: 'string', * lastName: 'string', * fullName: { * setter: false, * getter: function () { return this.firstName + ' ' + this.lastName; }, * dependencies: [ 'firstName', 'lastName' ], * }, * age: { * type: [ Number, undefined ], * defaultValue: 0, * }, * someData: {}, * }) * ``` * Here we see a schema with five properties. The first two (_firstName_ and _lastName_) use a shorthand syntax to declare string properties. The _fullName_ property is a calculated property that depends on _firstName_ and _lastName_. The _age_ property is either a number or undefined (properties can't be undefined by default), with a default value of 0. Finally, the _someData_ property can be of any type. * @func * @static * @arg {Object} schema - An object describing the properties that will be part of all new instances created by the returned constructor function. Each key/value pair describes a single property. Property descriptor objects can have the following properties: * * _type_: A string or array of strings specifying the type of the property. If omitted, no type checking will be performed, otherwise types are checked by applying the typeof operator to the assigned value and then checking to see if the returned type string is part of the schema types. * * _defaultValue_: An initial value that will be assigned to all new instances of this property upon creation. * * _setter_: A function that will be called to transform the assigned value before it is stored on the property. Shouldn't have any side effects, as it might be called internally to determine when events should be triggered. * * _getter_: A function that will be run to transform the read value before it is returned. Shouldn't have any side effects, as it might be called internally to determine when events should be triggered. * * All schema descriptor properties are optional. An empty schema descriptor can be replaced with any falsy value for the same effect, which means that: * `someData: {}`, `someData: undefined`, `someData: null` and `someData: false` all declares a property named someData, which can hold any type of data. * * There is also a shorthand syntax for specifying typed properties, because it is such a common use case, e.g.: * `aProp: String` is equal to `aProp: { type: String }` and e.g. * `aProp: [ String, undefined ]` is equal to `aProp: { type: [ String, undefined ] }` * * @arg {boolean} dontPreventExtensions - All extensions of records are prevented by default (using `Object.preventExtensions`), but that behavior can be toggled using this flag. * * @returns {function} New constructor function based on the provided schema. */ Record.withProperties = function (schema, dontPreventExtensions) { if (RUNTIME_CHECKS) { if (typeof schema !== 'object') { throw '&quot;schema&quot; argument must be an object'; } if (arguments.length &gt; 1 &amp;&amp; typeof dontPreventExtensions !== 'boolean') { throw '&quot;dontPreventExtensions&quot; must be a boolean value'; } } var RecordSubclass = function RecordSubclass(values) { this.__private || Object.defineProperty(this, '__private', { writable: true, value: {}, }); this.__private.schema = schema; Record.call(this, values); dontPreventExtensions || Object.preventExtensions(this); }; RecordSubclass.prototype = Object.create(Record.prototype); RecordSubclass.prototype.constructor = RecordSubclass; var props = {}; for (var propName in schema) { var propSchema = schema[propName] = schema[propName] || {}; // Convert shorthand aProp: SomeType into aProp: { type: SomeType } if (!isPlainishObject(propSchema)) { propSchema = schema[propName] = { type: propSchema }; } if (!('type' in propSchema)) { propSchema.type = [ ANY_TYPE ]; } if (!(propSchema.type instanceof Array)) { propSchema.type = [ propSchema.type ]; } if (RUNTIME_CHECKS) { for (var i = 0, n = propSchema.type.length; i &lt; n; ++i) { var type = propSchema.type[i]; if (type instanceof Function || type === ANY_TYPE || type === null || type === undefined) { continue; } throw 'All property type identifiers must be constructor functions, or null, or undefined - ' + propName + ' is not'; } } props[propName] = { enumerable: true, get: propSchema.getter === false ? undefined : makeGetter(propName, propSchema), set: propSchema.setter === false ? undefined : makeSetter(propName, propSchema), }; } Object.defineProperties(RecordSubclass.prototype, props); return RecordSubclass; }; return Record; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([ './extend', './event-emitter', './event-listener' ], moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(require('./extend'), require('./event-emitter'), require('./event-listener')); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.Record = moduleFactory(bff.extend, bff.eventEmitter, bff.eventListener); } }()); × Search results Close "},"view.js.html":{"id":"view.js.html","title":"Source: view.js","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Source: view.js /* global RUNTIME_CHECKS, define */ (function () { 'use strict'; /** * Encapsulates typical MVC view functionality. Note that BFF lacks a separate controller module and it is not wrong put controller logic in BFF Views. * * The intended way to combine BFF Records/Lists and Views into some kind or MVC-like pattern is as follows: * * Views listen to DOM events, and reacts to those by mutating data layer entities (such as models or lists of models) * * Views also listen to data layer events and reacts to those, possibly by further mutating the data layer (i.e. controller logic), but most importantly by re-rendering themselves. * * Another way of describing the above is that the views should, besides listening to user generated events, always strive to visually represent the data layer as truthfully as possible. A powerful and simple approach to achieving this is to re-render the whole view whenever the data layer changes. * * The three major issues to deal with when re-rendering an entire view are: * * _Loss of view state._ This is a generic problem, that thankfully has an easy solution; store all application state in the data layer. A typical way of doing this is to assign a view state model to views that are not stateless. * * _Loss of event listeners_. The typical solution to this is event delegation, which is also the soliution that BFF Views provide. All event listeners are registered on the view's root element and as long as the root elements is not replaced, the event listeners will be unaffecte by a re-render. * * _Visual flickering_. Replacing large chunks of the visual DOM may cause flickering. BFF Views work around this issue by using an approach similar to that of React, namely by differentially updating the DOM. This means doing an offline diff and then only updating the parts of the DOM that have actually changed. * @exports bff/view */ function moduleFactory(extend, eventEmitter, eventListener, patch, List) { var HTML_PARSER_EL = document.createElement('div'); var elMatchesSelector = document.body.matches ? function (el, selectorStr) { return el.matches(selectorStr); } : function (el, selectorStr) { return el.msMatchesSelector(selectorStr); }; var myRequestAnimationFrame = window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (callback) { setTimeout(callback, 1000 / 60); }; /** * Creates a new View instance. * @constructor * @mixes module:bff/event-emitter * @mixes module:bff/event-listener * @alias module:bff/view */ function View() { Object.defineProperty(this, '__private', { writable: true, value: {}, }); this.__private.isRenderRequested = false; var delegates = this.__private.eventDelegates = {}; this.__private.onDelegatedEvent = function onDelegatedEvent(ev) { var delegatesForEvent = delegates[ev.type]; var el = ev.target; for (var selectorStr in delegatesForEvent) { if (!elMatchesSelector(el, selectorStr)) { continue; } var delegatesForEventAndSelector = delegatesForEvent[selectorStr]; for (var i = 0, n = delegatesForEventAndSelector.length; i &lt; n; ++i) { delegatesForEventAndSelector[i](ev); } } }; /** * The root DOM element of the view. The default implementation of {@link module:bff/view#render} assigns to and updates this element. Delegated event listeners, created by calling {@link module:bff/view#listenTo} are attached to this element. * Replacing the current element with another will clear all currently delegated event listeners - it is usually a better approach update the element (using e.g. {@link module:bff/patch-dom}) instead of replacing it. * @instance * @member {HTMLElement|undefined} el */ Object.defineProperty(this, 'el', { enumerable: true, get: function () { return this.__private.el; }, set: function (el) { this.stopListening('*'); this.__private.el = el; } }); this.__private.childViews = new List(); this.listenTo(this.__private.childViews, 'item:destroyed', function (childView) { this.__private.childViews.remove(childView); }); /** * A list of this view's child views. Initially empty. * @instance * @member {module:bff/list} children */ Object.defineProperty(this, 'children', { enumerable: true, get: function () { return this.__private.childViews; }, }); } extend(View.prototype, eventEmitter); extend(View.prototype, eventListener); extend(View.prototype, { /** * Destroys a view instance by removing its children, stop listening to all events and finally removing itself from the DOM. * @instance */ destroy: function () { this.destroyChildren(); this.stopListening(); this.el &amp;&amp; this.el.parentNode &amp;&amp; this.el.parentNode.removeChild(this.el); this.emit('destroyed', this); }, /** * Creates a DOM representation of the view, based on the HTML string returned by the getHtml() function and then assigns it to the view's `el` property. If the view already has an `el`, it will be patched instead of replaced, so that delegated event listeners will be preserved. * @instance * @arg {Object} [patchOptions] - Options object forwarded to the `patch()` function, in case it is called. */ render: function (patchOptions) { if (RUNTIME_CHECKS) { if (!this.getHtml) { throw 'You must implement getHtml() in order to use render()'; } if (arguments.length &gt; 1 &amp;&amp; typeof patchOptions !== 'object') { throw '&quot;patchOptions&quot; argument must be an object'; } } var newEl = this.parseHtml(this.getHtml()); this.doPatch || newEl.setAttribute('patch-ignore', ''); if (this.el) { patch(this.el, newEl, patchOptions); } else { this.el = newEl; } }, /** * Requests an animation frame, in which `render()` is called. Can be called several times during a tick witout any performance penalty. * @instance */ requestRender: function () { if (this.__private.isRenderRequested) { return; } this.__private.isRenderRequested = true; var self = this; myRequestAnimationFrame(function () { self.__private.isRenderRequested = false; self.render(); }); }, /** * Helper function that parses an HTML string into an HTMLElement hierarchy and returns the first element in the NodeList, unless the returnAll flag is true, in which case the whole node list is returned. * @instance * @arg {string} htmlString - The string to be parsed * @arg {boolean} returnAll - If true will return all top level elements */ parseHtml: function (htmlString, returnAll) { if (RUNTIME_CHECKS) { if (typeof htmlString !== 'string') { throw '&quot;htmlString&quot; argument must be a string'; } if (arguments.length &gt; 1 &amp;&amp; typeof returnAll !== 'boolean') { throw '&quot;returnAll&quot; argument must be a boolean value'; } } HTML_PARSER_EL.innerHTML = htmlString; if (RUNTIME_CHECKS &amp;&amp; !returnAll &amp;&amp; HTML_PARSER_EL.children.length &gt; 1) { throw 'The parsed HTML contains more than one root element.' + 'Specify returnAll = true to return all of them'; } var ret = returnAll ? HTML_PARSER_EL.children : HTML_PARSER_EL.firstChild; while (HTML_PARSER_EL.firstChild) { HTML_PARSER_EL.removeChild(HTML_PARSER_EL.firstChild); } return ret; }, /** * Scoped query selector, that only queries this view's DOM subtree. * @instance * @arg {string} queryString - CSS selector string */ $: function (queryString) { if (RUNTIME_CHECKS &amp;&amp; typeof queryString !== 'string') { throw '&quot;queryString&quot; argument must be a string'; } return this.el.querySelector(queryString); }, /** * Helper function that forces the view's root element to be repainted. Useful when re-triggering CSS animations. * @instance * @arg {HTMLElement} [el] Element that will be forced to repaint. If not specified, will default to the view's root element. * @returns {number} Useless/arbitrary value, but the function needs to return it to prevent browser JS optimizations from interfering with the forced repaint. */ forceRepaint: function (el) { if (RUNTIME_CHECKS &amp;&amp; arguments.length &gt; 0 &amp;&amp; !(el instanceof HTMLElement)) { throw '&quot;el&quot; argument must be an HTMLElement'; } return (el || this.el).offsetHeight; }, /** * Adds another view as a child to the view. A child view will be automatically added to this view's root element and destroyed whenever its parent view is destroyed. * @instance * @arg {module:bff/view} childView - The view that will be added to the list of this view's children. * @arg {HTMLElement|boolean} [optional] - An element to which the child view's root element will be appended. If not specified, it will be appended to this view's root element. Can also be `false`, in which case the child view will not be appended to anything. */ addChild: function (childView, el) { if (RUNTIME_CHECKS) { if (!(childView instanceof View)) { throw '&quot;childView&quot; argument must be a BFF View'; } if (arguments.length &gt; 1 &amp;&amp; !(el === false || el instanceof HTMLElement)) { throw '&quot;el&quot; argument must be an HTMLElement or the boolean value false'; } } this.__private.childViews.push(childView); el !== false &amp;&amp; (el || this.el).appendChild(childView.el); return childView; }, /** * Destroy all child views of this view. * @instance */ destroyChildren: function () { // Iterate backwards because the list might shrink while being iterated for (var i = this.__private.childViews.length - 1; i &gt;= 0; --i) { this.__private.childViews[i].destroy(); } }, /** * Augments {@link bff/event-listener#listenTo} with functionality for listening to delegated DOM events, by specifying a CSS selector string instead of an event emitter. The actual listener will implicitly be registered on this view's root element. Not the the &quot;mouseenter&quot; and &quot;mouseleave&quot; events does not bubble, so they might not behave as expected - &quot;mouseover&quot; and &quot;mouseout&quot; events on the other hand do bubble. * @instance * @arg {string|Object|Array|NodeList} selectorStr - The CSS selector string that will be used to filter all events bubbling up to the listener. If anything other than a string passed, the original listenTo implementation will be used. * @arg {string|Array} eventName - One or more string identifiers for events that will be listented to. * @arg {function} callback - The function that will be called when the event is emitted. * @arg {any} [context] - The context with which the callback will be called (i.e. what &quot;this&quot; will be). * Will default to the caller of .listenTo, if not provided. */ listenTo: function (selectorStr, eventName, callback, context, useCapture) { if (typeof selectorStr !== 'string') { eventListener.listenTo.apply(this, arguments); return; } if (eventName instanceof Array &amp;&amp; eventName.length &gt; 0) { this.listenTo(selectorStr, eventName.pop(), callback, context, useCapture); this.listenTo(selectorStr, eventName, callback, context, useCapture); return; } if (RUNTIME_CHECKS) { if (typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } if (typeof callback !== 'function') { throw '&quot;callback&quot; argument must be a function'; } if (arguments.length &gt; 4 &amp;&amp; typeof useCapture !== 'boolean') { throw '&quot;useCapture&quot; argument must be a boolean value'; } } var delegates = this.__private.eventDelegates; var delegatesForEvent = delegates[eventName]; if (!delegatesForEvent) { delegatesForEvent = (delegates[eventName] = {}); useCapture = useCapture || eventName === 'blur' || eventName === 'focus'; eventListener.listenTo.call(this, this.el, eventName, this.__private.onDelegatedEvent, undefined, useCapture); } delegatesForEvent[selectorStr] = delegatesForEvent[selectorStr] || []; delegatesForEvent[selectorStr].push(callback.bind(context || this)); }, /** * Augments {@link bff/event-listener#stopListening} with functionality for stop listening to delegated DOM events. * @instance * @arg {string|Object} [selectorStr] - If provided, only delegated event callbacks for the given selector string will be removed. The special wildcard value `*` means _any_ selector. If anything other than a string passed, the original stopListening implementation will be used. * @arg {string} [eventName] - If provided, only callbacks attached to the given event name will be removed. */ stopListening: function (selectorStr, eventName) { if (typeof selectorStr !== 'string') { eventListener.stopListening.apply(this, arguments); if (selectorStr !== undefined) { return; } } if (RUNTIME_CHECKS &amp;&amp; arguments.length &gt; 1 &amp;&amp; typeof eventName !== 'string') { throw '&quot;eventName&quot; argument must be a string'; } var eventDelegates = this.__private.eventDelegates; // No event name means all event names var eventNames = eventName !== undefined ? [ eventName ] : Object.keys(eventDelegates); for (var i = 0, n = eventNames.length; i &lt; n; ++i) { eventName = eventNames[i]; var delegatesForEvent = eventDelegates[eventName]; if (!delegatesForEvent) { continue; } if (selectorStr &amp;&amp; selectorStr !== '*') { delete delegatesForEvent[selectorStr]; } else { // If no selector string has been specified, remove all event delegates for the event name eventDelegates[eventName] = {}; } if (Object.keys(eventDelegates[eventName]).length === 0) { delete this.__private.eventDelegates[eventName]; eventListener.stopListening.call(this, this.el, eventName); } } }, /** * @instance * @returns {string} A human readable representation of the View, containing valuable debugging information. */ toString: function () { return JSON.stringify({ 'element': this.el &amp;&amp; { type: '&lt;' + this.el.nodeName + '&gt;', children: this.el.childNodes.length, }, 'child views': this.__private.childViews.length, 'event listeners': Object.keys(this.__private.listeningTo), 'delegated events': Object.keys(this.__private.eventDelegates), }, undefined, 2); }, }, 'useSource'); /** * Creates a subclass constructor function, that will create view instances with the properties (typically functions) provded to this function. * @static * @arg {Object} properties - The properties with which the View subclass' prototype will be extended. * @returns {function} */ View.makeSubclass = function (properties) { if (RUNTIME_CHECKS &amp;&amp; typeof properties !== 'object') { throw '&quot;properties&quot; argument must be an object'; } var customConstructor = properties.constructor; var Constructor = function () { View.apply(this, arguments); customConstructor &amp;&amp; customConstructor.apply(this, arguments); }; delete properties.constructor; Constructor.prototype = Object.create(View.prototype); properties &amp;&amp; extend(Constructor.prototype, properties); Constructor.prototype.constructor = Constructor; return Constructor; }; return View; } // Expose, based on environment if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([ './extend', './event-emitter', './event-listener', './patch-dom', './list' ], moduleFactory); } else if (typeof exports === 'object') { // Node, CommonJS-like module.exports = moduleFactory(require('./extend'), require('./event-emitter'), require('./event-listener'), require('./patch-dom'), require('./list')); } else { // Browser globals var bff = window.bff = window.bff || {}; bff.View = moduleFactory(bff.extend, bff.eventEmitter, bff.eventListener, bff.patchDom, bff.List); } }()); × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Modules Classes module:bff/list module:bff/record module:bff/view Mixins bff/event-emitter bff/event-listener Events change:length Parameters: Name Type Description newLength number The current length of the List. oldLength number The previous length of the List. list module:bff/list The List whose length has changed. Source: list.js, line 39 item:added Parameters: Name Type Description item any The item that was added to the List. index number The position withing the List where the item was added. list module:bff/list The List to which the item was added. Source: list.js, line 17 item:removed Parameters: Name Type Description item any The item that was removed from the List. index number The position withing the List where the item was removed. list module:bff/list The List from which the item was removed. Source: list.js, line 32 item:replaced Parameters: Name Type Description newItem any The item that was added to the List. oldItem any The item that was removed from the List. index number The position withing the List where the item was replaced. list module:bff/list The List in which the item was replaced. Source: list.js, line 24 change:[property name] Emitted when the value of the property with name [property name] has changed. This event is only emitted if the assigned value actually differs from the previous one, compared using strict equality. Parameters: Name Type Description newValue any The new property value oldValue any The previous property value self module:bff/record The record that triggered the event Source: record.js, line 32 change Emitted when some property value has changed. This event is only emitted if the assigned value actually differs from the previous one, compared using strict equality. Parameters: Name Type Description propertyName string The name of the record property that has changed newValue any The new property value oldValue any The previous property value self module:bff/record The record that triggered the event Source: record.js, line 40 prechange Emitted when some property value is about to be assigned a new value. This event is always emitted upon assignment, even is the value to be assigned is the same as the current value. Parameters: Name Type Description propertyName string The name of the record property that is about to be assigned to currentValue any The current property value self module:bff/record The record that triggered the event Source: record.js, line 23 prechange:[property name] Emitted when the property with name [property name] is about to be assigned a new value. This event is always emitted upon assignment, even is the value to be assigned is the same as the current value. Parameters: Name Type Description currentValue any The current property value self module:bff/record The record that triggered the event Source: record.js, line 16 × Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Mixins Classes module:bff/list module:bff/record module:bff/view Mixins bff/event-emitter bff/event-listener Events change:length Parameters: Name Type Description newLength number The current length of the List. oldLength number The previous length of the List. list module:bff/list The List whose length has changed. Source: list.js, line 39 item:added Parameters: Name Type Description item any The item that was added to the List. index number The position withing the List where the item was added. list module:bff/list The List to which the item was added. Source: list.js, line 17 item:removed Parameters: Name Type Description item any The item that was removed from the List. index number The position withing the List where the item was removed. list module:bff/list The List from which the item was removed. Source: list.js, line 32 item:replaced Parameters: Name Type Description newItem any The item that was added to the List. oldItem any The item that was removed from the List. index number The position withing the List where the item was replaced. list module:bff/list The List in which the item was replaced. Source: list.js, line 24 change:[property name] Emitted when the value of the property with name [property name] has changed. This event is only emitted if the assigned value actually differs from the previous one, compared using strict equality. Parameters: Name Type Description newValue any The new property value oldValue any The previous property value self module:bff/record The record that triggered the event Source: record.js, line 32 change Emitted when some property value has changed. This event is only emitted if the assigned value actually differs from the previous one, compared using strict equality. Parameters: Name Type Description propertyName string The name of the record property that has changed newValue any The new property value oldValue any The previous property value self module:bff/record The record that triggered the event Source: record.js, line 40 prechange Emitted when some property value is about to be assigned a new value. This event is always emitted upon assignment, even is the value to be assigned is the same as the current value. Parameters: Name Type Description propertyName string The name of the record property that is about to be assigned to currentValue any The current property value self module:bff/record The record that triggered the event Source: record.js, line 23 prechange:[property name] Emitted when the property with name [property name] is about to be assigned a new value. This event is always emitted upon assignment, even is the value to be assigned is the same as the current value. Parameters: Name Type Description currentValue any The current property value self module:bff/record The record that triggered the event Source: record.js, line 16 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] , Basic Front-end Foundation BFF is a collection of standalone modules, designed with the intent of making it easier to design interactive web applications. It comprises base classes for the MVC pattern (Record, View) but more importantly, generic building blocks for event systems (Event Emitter, Event Listener), inheritance (Extend), collections (List) and DOM manipulation (Patch DOM). Its ambition is to be a helper library rather than a framework, to be mixed and matched with home grown or third-party components. As such, each BFF module provides a specific service, with a minimal interface. All modules are UMD compatible, which means that they support AMD and CommonJS loaders, as well as no loader at all. Distinguishing features Modular and without external dependencies. Two versions; development and production. The former with lots of runtime error checking, the latter minified and without error checks, for optimal performance. Fast and fool-proof event system - uses inversion-of-control to automatically keep track of registered event listeners. Data modules (Record and List) combine event system with getters and setters, to create an event emitting, type safe, data layer that can be manipulated with the same syntax as plain JS objects. Data modules support calculated properties, similar to signals in FRP, whose values are derived from one or more other properties - and still emits events when their calculated values change. View module inspired by Backbone.js views, with the addition of React-like DOM patching and hierarchical structuring. Compatibility Latest versions (and presumably earlier) of Chrome, Firefox, Safari and Opera Internet Explorer 9 and later Node.js (except View and Patch DOM modules, which naturally require a browser environment) Download Run npm install bff-lib --save or bower install bff-lib --save in your project's root folder Or, download a release directly from here. DemosTodo application (source) DocumentationAPI reference Want to contribute?Buildingnpm install will install all project dev. dependencies. grunt will lint the project, build dev and prod versions of BFF, compile JSDoc documentation, and run the Intern test suite grunt watch will watch for source file changes and recompile the source and documentation Running testsUnit tests in browserGo to [server root]/node_modules/intern/client.html?config=tests/intern in some browser Unit tests in terminal (Node.js)Run node_modules/.bin/intern-client config=tests/intern Unit tests and functional tests in browser Start a standalone Selenium server java -jar [path to selenium jar] Run grunt test × Search results Close "},"bff_event-emitter.html":{"id":"bff_event-emitter.html","title":"Mixin: bff/event-emitter","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Mixin: bff/event-emitter bff/event-emitter A mixin, providing event emitting capabilities to an object. Events are simply strings. When they are emitted, zero or more parameters can be passed as arguments to the listening functions. Source: event-emitter.js, line 12 Methods addEventListener(eventName, callback) Add an event listener function that will be called whenever the given event is emitted. Trying to add the exact same function twice till throw an error, as that is rarely ever the intention and a common source of errors. Parameters: Name Type Description eventName string Identifier string for the event that is to be listened to. callback function The function that will be called when the event is emitted. Source: event-emitter.js, line 69 emit(eventName [, eventArguments]) Emit an event. Callbacks will be called with the same arguments as this function was called with, except for the event name argument. Parameters: Name Type Argument Description eventName string Identifier string for the event. eventArguments any &lt;optional&gt; &lt;repeatable&gt; Zero or more arguments that event listeners will be called with. Source: event-emitter.js, line 19 emitArgsAsArray(eventName [, argsArray]) Emit an event. Callbacks will be called with arguments given as an an array in the second argument Parameters: Name Type Argument Description eventName string Identifier string for the event. argsArray Array &lt;optional&gt; An array of arguments with which the callbacks will be called. Each item in the array will be provided as an individual argument to the callbacks. Source: event-emitter.js, line 43 removeEventListener(eventName [, callback]) Removes an event listener function. If the function was never a listener, do nothing. Parameters: Name Type Argument Description eventName string Identifier string for the event in question. callback function &lt;optional&gt; If not given, all event listeners to the provided eventName will be removed. If given, only the given callback will be removed from the given eventName. Source: event-emitter.js, line 96 × Search results Close "},"bff_event-listener.html":{"id":"bff_event-listener.html","title":"Mixin: bff/event-listener","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Mixin: bff/event-listener bff/event-listener A mixin, providing event listening capabilities to an object. This is an inversion-of-control with regards to regular event listening; the listener maintains a list of the events it is listening to. This allows the listener to remove some or all its event listeners, for instance when it is disabled or destroyed. This is an easy way to avoid leaking listeners. Caveat: don't mix eventEmitter.removeEventListener and eventListener.stopListening throughout a project, as that could result in memory leaks. Source: event-listener.js, line 44 Methods listenTo(eventEmitters, eventNames, callback [, context]) Start listening to an event on a specified event emitting object. Both eventEmitters and eventNames arguments can be arrays. The total amount of listeners added will be the Cartesian product of the two lists. Parameters: Name Type Argument Description eventEmitters Object | Array | NodeList One or more event emitters that will be listened to. eventNames string | Array One or more string identifiers for events that will be listented to. callback function The function that will be called when the event is emitted. context any &lt;optional&gt; The context with which the callback will be called (i.e. what &quot;this&quot; will be). Will default to the caller of .listenTo, if not provided. Source: event-listener.js, line 55 stopListening( [eventEmitter] [, eventName]) Stop listening to events. If no arguments are provided, the listener removes all its event listeners. Providing any or both of the optional arguments will filter the list of event listeners removed. Parameters: Name Type Argument Description eventEmitter Object &lt;optional&gt; If provided, only callbacks attached to the given event emitter will be removed. eventName string &lt;optional&gt; If provided, only callbacks attached to the given event name will be removed. Source: event-listener.js, line 91 × Search results Close "},"module-bff_extend.html":{"id":"module-bff_extend.html","title":"Module: bff/extend","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Module: bff/extend (require(&quot;bff/extend&quot;))(target, source [, onConflict] [, defaultOnConflict]) A function that extends a target object with the properties of a source object, with options for describing property collision behavior. Note that the target object is mutated and returned, i.e. no new object gets created by invoking this function. The function comes with a set of named built-in conflict-solving functions: crash: Throws an error when a property conflict occurs. This is the default solver function. useTarget: Uses the target's property, i.e. leaves the target property unchanged. useSource: Uses the source's property, i.e. overwrites the target property with the source property. merge: Tries to merge the values in an intuitive way. Objects are merged recursively. Arrays are concatenated. Functions are combined, so that the target's function is first called, then the source's. Both functions are passed the same arguments. Numbers and strings added using the + operator. Boolean values are or:ed using the || operator (i.e. Boolean addition). If the source and target types are not the same, use the source value.The caller also has the option to specify custom solver functions. Examples extend( { a: { b: 'b', c: 'c' } }, { a: { c: 'c', d: 'd' } }, 'useSource'); // Returns { a: { c: 'c', d: 'd' } }As can be seen in above, the 'useSource' conflict solver is not recursive, it simply overwrites any property it encounters. This is how e.g. jQuery.extend and _.assign behaves. extend( { a: { b: 'b', c: 'c' } }, { a: { c: 'c', d: 'd' } }, 'merge'); // Returns { a: { b: 'b', c: 'c', d: 'd' } }Here we see that the 'merge' solver works recursively. extend( { a: { b: 'b' }, num: 1 }, { a: { c: 'c' }, num: 2 }, { object: 'merge' }, 'useSource'); // Returns { a: { b: 'b', c: 'c' }, num: 2 }The above example uses the 'merge' solver on objects and the 'useSource' solver on all other property types. This produces a recursive behavior over objects, which is quite often desired. This is how e.g. _.merge behaves extend( { a: { b: 'b' }, num: 1 }, { a: { c: 'c' }, num: 2, newProp: 3 }, function (target, source, prop) { target[prop] = 42; }); // Returns { a: 42, num: 42, newProp: 3 }Above we see a (fairly useless) custom conflict solver function. Parameters: Name Type Argument Description target Object The object that will be extende with new properties. source Object The object that provides the new properties. onConflict string | module:bff/extend~conflictSolver | Object &lt;optional&gt; Specifies how to handle cases where a property exists both on the target and on the source. a string argument will be used to identify one of the built in solver functions. Valid values are 'useTarget', 'useSouce', 'crash' and 'merge'. a function argument will be used as-is as a solver for all conflicts. an Object argument should have keys that correspond to value types, i.e. 'object', 'array', 'function', 'string', 'number', 'boolean', 'null' or 'undefined'. The object values can be either strings or functions, which will be used as solver functions for the corresponding key value types. defaultOnConflict string | module:bff/extend~conflictSolver &lt;optional&gt; Specifies a default solver, in the same manner as the onConflict argument. Can only be used if onConflict is an object. Source: extend.js, line 85 Returns: The extended object Type Object Type Definitions conflictSolver(target, source, prop, onConflict, defaultOnConflict) Parameters: Name Type Description target Object source Object prop string The name of the conflicting property. onConflict string | module:bff/extend~conflictSolver | Object The same onConflict argumet passed to the extend() call. defaultOnConflict string | module:bff/extend~conflictSolver The same defaultOnConfluct argumet passed to the extend() call. Source: extend.js, line 17 × Search results Close "},"module-bff_list.html":{"id":"module-bff_list.html","title":"Module: bff/list","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Module: bff/list Maintains a list of items. The idea is to stay as true as possible to the native Array interface, but to augment its usefulness by triggering events whenever the list is updated, as well as adding convenience functions for mutating the List in place. The exported List constructor can be used as-is, in which case a generic List will be created. This is a quite common use case. Alternatively, a List &quot;subclass&quot; constructor can be created by calling List.withProperties(...). This second approach provides the possibility to add custom calculated properties to the list. See module:bff/list#withProperties for more details. new (require(&quot;bff/list&quot;))( [items]) Creates a new List, with an optional list or array of initial items. Parameters: Name Type Argument Description items Array | List &lt;optional&gt; Items that will be added to the List on creation. Mixes In: bff/event-emitter bff/event-listener Source: list.js, line 798 Methods &lt;static&gt; withProperties(schema) Creates a new List constructor function, that will create List instances with the property schemaprovided to this function Parameters: Name Type Description schema Object An object describing the properties that will be part of all new instances created by the returned constructor function. The property descriptions should be on the same format at the schema specified for module:bff/record.withProperties, with the only exception that setters are not allowed. Source: list.js, line 808 Returns: New constructor function based on the provided schema. Type function addEventListener(eventName) Augmented version of bff/event-emitter#addEventListener that provides the option to listen to events emitted from any item in the List. To add a listener to an item event, prepend the event name with 'item:'. For instance, to listen for the 'change' event on all the list items (even ones added after the listener was created), add a listener for the 'item:change' event. Parameters: Name Type Description eventName string Identifier string for the event. Source: list.js, line 668 clear() Mutates the List by removing all items. Source: list.js, line 508 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: The List, now empty. Type List concat(value) Returns a new List comprised of the List on which it is called joined with the List(s), Array(s) and/or value(s) provided as arguments. Mirrors the behavior of Array.concat. Parameters: Name Type Argument Description value any &lt;repeatable&gt; A List, Array or value that will be concatenated with the original List. Lists and Arrays will be deconstructed and each item added to the new List. Source: list.js, line 453 Returns: The new List. Type List every(predicate [, thisArg]) Mirrors Array.every behavior. Parameters: Name Type Argument Description predicate module:bff/list~predicateCallback Executed once per List item. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 331 Returns: true if all items passes the predicate test, false otherwise. Type boolean filter(predicate) Creates a new List with all items that pass the test implemented by the predicate function test. The original list is unchanged. Mirrors the behavior of Array.filter. Parameters: Name Type Description predicate module:bff/list~predicateCallback Executed once per List item. Source: list.js, line 415 Returns: The new List. Type List filterMut(predicate [, thisArg]) Mutates the List by removing all items that does not pass the predicate function test. Parameters: Name Type Argument Description predicate module:bff/list~predicateCallback Called once per List item to determine whether the item should be removed. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing predicate callback. Source: list.js, line 472 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: The filtered List. Type List find(predicate) Returns the first item in the List that passes the predicate function test, or undefined if no item passes. Parameters: Name Type Description predicate module:bff/list~predicateCallback Called once per List item to in order to find a matching item. Source: list.js, line 590 Returns: The matching item, if any. Type any | undefined findIndex(predicate) Returns the index of the first item in the List that passes the predicate function test, or -1 if no item passes. Parameters: Name Type Description predicate module:bff/list~predicateCallback Called once per List item to in order to find a matching item. Source: list.js, line 604 Returns: The position of the matching item, or -1 if none matches. Type number forEach(callback [, thisArg]) Executes the given function once per List item. Mirrors Array.forEach behavior. Parameters: Name Type Argument Description callback module:bff/list~forEachCallback The function that will be called once per List item. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 323 includes(item [, fromIndex]) Returns whether the provided item is part of the List. Parameters: Name Type Argument Description item any fromIndex number &lt;optional&gt; The index to start the search at. If the index is greater than or equal to the List's length, -1 is returned, which means the List will not be searched. If the provided index value is a negative number, it is taken as the offset from the end of the List. Source: list.js, line 620 Returns: True if the item is part of the List, false otherwise. Type boolean indexOf(searchItem [, fromIndex]) Mirrors Array.indexOf behavior. Parameters: Name Type Argument Description searchItem any The item to locate within the List. fromIndex number &lt;optional&gt; The index to start the search at. If the index is greater than or equal to the List's length, -1 is returned, which means the List will not be searched. If the provided index value is a negative number, it is taken as the offset from the end of the List. Source: list.js, line 349 Returns: The first index at which a given item can be found in the List, or -1 if it is not present. Type number join( [separator]) Parameters: Name Type Argument Description separator string &lt;optional&gt; Specifies a string to separate each item of the List. If omitted, the List items are separated with a comma. Mirrors Array.join behavior. Source: list.js, line 366 Returns: The stringified List items, joined by the 'separator' string argument. Type string lastIndexOf(searchItem [, fromIndex]) Parameters: Name Type Argument Description searchItem any The item to locate within the List. fromIndex number &lt;optional&gt; The index at which to start searching backwards. Defaults to the List's length minus one, i.e. the whole List will be searched. If the index is greater than or equal to the length of the List, the whole List will be searched. If negative, it is taken as the offset from the end of the List. Mirrors Array.lastIndexOf behavior. Source: list.js, line 358 Returns: The last index at which a given item can be found in the List, or -1 if it is not present. Type number map(callback [, thisArg]) Creates a new List with the results of calling a provided callback function on every element in the List. Mirrors the behavior of Array.map. Parameters: Name Type Argument Description callback module:bff/module~mapCallback Executed once per List item. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 434 Returns: The new List. Type List mapMut(callback [, thisArg]) Replaces all items in the List with new items, generated by the callback function. Parameters: Name Type Argument Description callback module:bff/module~mapCallback Executed once per List item to produce new items. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 575 Fires: module:bff/list#item:replaced Returns: The List, with all items updated. Type List pop() Remove and return one item from the end of the List. Mirrors Array.pop behavior. Source: list.js, line 231 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: Removed item Type any propertiesToJSON() Returns a newly created Object containing the List's deep copied properties. Source: list.js, line 659 Returns: Type Object push(item) Add one or more items to the end of the List. Mirrors Array.push behavior. Parameters: Name Type Argument Description item any &lt;repeatable&gt; Each item argument will be pushed onto the List. Source: list.js, line 180 Fires: module:bff/list#change:length module:bff/list#item:added Returns: Updated List length Type number pushAll(items) Mutates the List by adding the items comprising the provided List or Array to the end of the List. Parameters: Name Type Description items module:bff/list | Array The items that will be appended to the List. Source: list.js, line 520 Fires: module:bff/list#change:length module:bff/list#item:added Returns: The List, with new items appended. Type List reduce(callback, initialValue) Applies a function against an accumulator and each value of the List (from left-to-right) to reduce it to a single value. Mirrors Array.reduce behavior. Parameters: Name Type Description callback module:bff/list~reduceCallback The function that will be called once per List item. initialValue any Value to use as the first argument to the first call of the callback. Source: list.js, line 373 Returns: Aggregated value Type any reduceRight(callback, initialValue) Applies a function against an accumulator and each value of the List (from right-to-left) to reduce it to a single value. Mirrors Array.reduceRight behavior. Parameters: Name Type Description callback module:bff/list~reduceCallback The function that will be called once per List item. initialValue any Value to use as the first argument to the first call of the callback. Source: list.js, line 382 Returns: Aggregated value Type any remove(item) Mutates the List by removing all occurances of the provided item. Parameters: Name Type Description item any The item to remove from the list. Source: list.js, line 497 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: The List, without any occurances of 'item'. Type List removeEventListener(eventName) Augmented version of bff/event-emitter#removeEventListener that provides functionality for removing &quot;item&quot; event listeners, e.g. for stop listening to events like &quot;items:change&quot;. Parameters: Name Type Description eventName string Identifier string for the event. Source: list.js, line 688 reverse() Reverses the List in place. Mirros the behavior of Array.reverse. No events are emitted by this operation. Source: list.js, line 404 shift() Remove and return one item from the beginning of the List. Mirrors Array.shift behavior. Source: list.js, line 253 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: Removed item Type any slice( [begin] [, end]) Creates a new List from the range of current items specified by the begin and end arguments. Mirrors the behavior of Array.slice. Parameters: Name Type Argument Description begin number &lt;optional&gt; Index that specifies the beginning of the range. Inclusive. A negative index will be relative to the end of the List instead of the beginning. end number &lt;optional&gt; Index that specifies the end of the range. Exclusive. A negative index will be relative to the end of the List instead of the beginning. Source: list.js, line 423 Returns: The new List. Type List sliceMut( [begin] [, end]) Mutates the List by removing all elements outside of range specified by the begin and end arguments. Parameters: Name Type Argument Description begin number &lt;optional&gt; Index that specifies the beginning of the range. Inclusive. A negative index will be relative to the end of the List instead of the beginning. end number &lt;optional&gt; Index that specifies the end of the range. Exclusive. A negative index will be relative to the end of the List instead of the beginning. Source: list.js, line 537 Fires: module:bff/list#change:length module:bff/list#item:removed Returns: The List, sans the items outside of the specified range. Type List some(predicate [, thisArg]) Mirrors Array.some behavior. Parameters: Name Type Argument Description predicate module:bff/list~predicateCallback Executed once per List item. thisArg any &lt;optional&gt; Value to use as &quot;this&quot; when executing callback. Source: list.js, line 340 Returns: true if at least one item passes the predicate test, false otherwise. Type boolean sort( [comparator]) Sorts the items of the List in place. The sort is not necessarily stable. The default sort order is according to string Unicode code points, unless a custom comparator finction is provided. Mirrors the behavior of Array.sort. No events are emitted by this operation. Parameters: Name Type Argument Description comparator module:bff/list~compareFunction &lt;optional&gt; A function that specifies the ordering of two arbitrary List items. Called multiple times in order to produce a total ordering of the items. Source: list.js, line 396 Returns: The sorted list. Type List splice(start, nItemsToRemove [, itemToAdd]) Changes the content of the List by removing existing items and/or adding new items. Mirrors Array.splice behavior. Parameters: Name Type Argument Description start number Index at which to start changing the array. If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many items from the end. nItemsToRemove number An integer indicating the number of old array items to remove. If nItemsToRemove is greater than the number of items left in the array starting at start, then all of the items through the end of the array will be deleted. itemToAdd any &lt;optional&gt; &lt;repeatable&gt; Item that will be added to the array, starting at the index specified in the first argument. Source: list.js, line 280 Fires: module:bff/list#change:length module:bff/list#item:added module:bff/list#item:replaced module:bff/list#item:removed Returns: Array of removed items Type Array.&lt;any&gt; toArray() Returns an newly created Array, containing all the items of the List. List properties are not copied to the Array object. The items are copied shallowly. Source: list.js, line 635 Returns: Type Array toJSON() Returns a newly created Array representation of the List, containing deep copies of all the List's items, but not its properties. Source: list.js, line 644 Returns: Type Array toString() Source: list.js, line 710 Returns: A human readable string representation of the List. Type string unshift(item) Add one or more items to the beginning of the List. Mirrors Array.unshift behavior. Parameters: Name Type Argument Description item any &lt;repeatable&gt; Each item argument will be pushed onto the List. Source: list.js, line 206 Fires: module:bff/list#change:length module:bff/list#item:added Returns: Updated List length Type Number Type Definitions compareFunction(itemA, itemB) Compares itemA and itemB arguments according to some sorting criterion. Should return -1 if itemA comes before itemB, 0 if itemA is equal to itemB, 1 if itemB comes before itemA. Parameters: Name Type Description itemA any A list item. itemB any Another list item. Source: list.js, line 85 Returns: . Type number forEachCallback(item, index, list) Parameters: Name Type Description item any Current List item. index number Item position in List. list module:bff/list List being iterated over. Source: list.js, line 53 mapCallback(item, index, list) Parameters: Name Type Description item any Current List item. index number Item position in List. list module:bff/list List being iterated over. Source: list.js, line 60 Returns: Transformed object. Type any predicateCallback(item, index, list) Parameters: Name Type Description item any Current List item. index number Item position in List. list module:bff/list List being iterated over. Source: list.js, line 68 Returns: true if the item passes the test, false otherwise Type boolean reduceCallback(previousItem, item, index, list) Parameters: Name Type Description previousItem any The value previously returned in the last invocation of the callback, or initialValue, if supplied. Usually an aggregate of previous items. item any Current List item being processed. index number Item position in List. list module:bff/list List being iterated over. Source: list.js, line 76 Returns: The aggregated value. Type any Events change:length Parameters: Name Type Description newLength number The current length of the List. oldLength number The previous length of the List. list module:bff/list The List whose length has changed. Source: list.js, line 39 item:added Parameters: Name Type Description item any The item that was added to the List. index number The position withing the List where the item was added. list module:bff/list The List to which the item was added. Source: list.js, line 17 item:removed Parameters: Name Type Description item any The item that was removed from the List. index number The position withing the List where the item was removed. list module:bff/list The List from which the item was removed. Source: list.js, line 32 item:replaced Parameters: Name Type Description newItem any The item that was added to the List. oldItem any The item that was removed from the List. index number The position withing the List where the item was replaced. list module:bff/list The List in which the item was replaced. Source: list.js, line 24 × Search results Close "},"module-bff_patch-dom.html":{"id":"module-bff_patch-dom.html","title":"Module: bff/patch-dom","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Module: bff/patch-dom (require(&quot;bff/patch-dom&quot;))(target, source [, options]) Patches the target element and its child elements such that it will be identical to the source element and its child structure. It achieves this by recursively patching, removing or adding elements in the target element hierarchy. The overall logic of the algorithm goes as follows: If the target and source elements have differing node type types (e.g. a &lt;div&gt; and a &lt;span&gt; tag) the target element is replaced by the source element. Otherwise, if the target and source elements are of the same type (e.g. two &lt;div&gt; tags), the attributes of the target element will be replaced by those of the target element. Then the target and source elements' children lists are compared using a version of the Levenshtein algorithm. This results in the children of the target element being either patched (by calling patchDom recursively) or removed. Child elements only present in the source child list will also be added to the target child list at their respective positions. If any encountered target elements has a patch-ignore attribute, that node and its children will not be patched. Parameters: Name Type Argument Description target HTMLElement The element (hierarchy) to be patched. Will be identical to the source element (hierarchy) after the function call completes. source HTMLElement The element (hierarchy) that the target (hierarchy) will be transformed into. options Object &lt;optional&gt; Options that will be recursively passed down to all patchDom calls. Currently only one option is implemented: ignoreSubtreeOf: A CSS selector string that identifies any elements, whose subtrees will not be patched. Source: patch-dom.js, line 239 × Search results Close "},"module-bff_record.html":{"id":"module-bff_record.html","title":"Module: bff/record","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Module: bff/record A Record is the basic entity of the data layer. In difference to regular JS objects, it has a predefined set of properties. The properties are specified by &quot;subclassing&quot; the abstract Record constructor by calling Record.withProperties(...) and providing a properties schema. For more details, see module:bff/record.withProperties. The major advantages of using a predefined (i.e. known and finite) set of properties are: Each property gets a custom setter, that emits a change event whenever the property value changes. The setter can also do types checks on the assigned value (which it does in dev. mode). The record instances can be locked using Object.preventExtensions, with the nice effect that trying to assign a value to an undeclared property will throw an error. new (require(&quot;bff/record&quot;))( [values]) Creates a new Record (subclass) with an optional set of initial values. Parameters: Name Type Argument Description values Object | module:bff/record &lt;optional&gt; An object containing initial values for the Record to be created. Mixes In: bff/event-emitter bff/event-listener Source: record.js, line 157 Methods &lt;static&gt; withProperties(schema, dontPreventExtensions) Creates a new Record constructor function, that will create Record instances with the property schema provided to this function. The various aspects of the property schema are described in detail below, but let's start with an example. var Person = Record.withProperties({ firstName: 'string', lastName: 'string', fullName: { setter: false, getter: function () { return this.firstName + ' ' + this.lastName; }, dependencies: [ 'firstName', 'lastName' ], }, age: { type: [ Number, undefined ], defaultValue: 0, }, someData: {}, })Here we see a schema with five properties. The first two (firstName and lastName) use a shorthand syntax to declare string properties. The fullName property is a calculated property that depends on firstName and lastName. The age property is either a number or undefined (properties can't be undefined by default), with a default value of 0. Finally, the someData property can be of any type. Parameters: Name Type Description schema Object An object describing the properties that will be part of all new instances created by the returned constructor function. Each key/value pair describes a single property. Property descriptor objects can have the following properties: type: A string or array of strings specifying the type of the property. If omitted, no type checking will be performed, otherwise types are checked by applying the typeof operator to the assigned value and then checking to see if the returned type string is part of the schema types. defaultValue: An initial value that will be assigned to all new instances of this property upon creation. setter: A function that will be called to transform the assigned value before it is stored on the property. Shouldn't have any side effects, as it might be called internally to determine when events should be triggered. getter: A function that will be run to transform the read value before it is returned. Shouldn't have any side effects, as it might be called internally to determine when events should be triggered. All schema descriptor properties are optional. An empty schema descriptor can be replaced with any falsy value for the same effect, which means that:someData: {}, someData: undefined, someData: null and someData: false all declares a property named someData, which can hold any type of data. There is also a shorthand syntax for specifying typed properties, because it is such a common use case, e.g.:aProp: String is equal to aProp: { type: String } and e.g.aProp: [ String, undefined ] is equal to aProp: { type: [ String, undefined ] } dontPreventExtensions boolean All extensions of records are prevented by default (using Object.preventExtensions), but that behavior can be toggled using this flag. Source: record.js, line 302 Returns: New constructor function based on the provided schema. Type function toJSON() Returns a newly created Object containing the Records's deep copied properties. The fact that this function returns an Object and not a strin is a bit misleading, but this naming convension is used for conformity reasons, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior Source: record.js, line 244 Returns: Type Object toString() Source: record.js, line 257 Returns: A human readable string representation of the Record. Type string Events change:[property name] Emitted when the value of the property with name [property name] has changed. This event is only emitted if the assigned value actually differs from the previous one, compared using strict equality. Parameters: Name Type Description newValue any The new property value oldValue any The previous property value self module:bff/record The record that triggered the event Source: record.js, line 32 change Emitted when some property value has changed. This event is only emitted if the assigned value actually differs from the previous one, compared using strict equality. Parameters: Name Type Description propertyName string The name of the record property that has changed newValue any The new property value oldValue any The previous property value self module:bff/record The record that triggered the event Source: record.js, line 40 prechange Emitted when some property value is about to be assigned a new value. This event is always emitted upon assignment, even is the value to be assigned is the same as the current value. Parameters: Name Type Description propertyName string The name of the record property that is about to be assigned to currentValue any The current property value self module:bff/record The record that triggered the event Source: record.js, line 23 prechange:[property name] Emitted when the property with name [property name] is about to be assigned a new value. This event is always emitted upon assignment, even is the value to be assigned is the same as the current value. Parameters: Name Type Description currentValue any The current property value self module:bff/record The record that triggered the event Source: record.js, line 16 × Search results Close "},"module-bff_view.html":{"id":"module-bff_view.html","title":"Module: bff/view","body":" BFF Modules bff/extendbff/listbff/patch-dombff/recordbff/view Mixins bff/event-emitterbff/event-listener Events bff/list#change:lengthbff/list#item:addedbff/list#item:removedbff/list#item:replacedbff/record#change:[property name]bff/record#event:changebff/record#event:prechangebff/record#prechange:[property name] Module: bff/view Encapsulates typical MVC view functionality. Note that BFF lacks a separate controller module and it is not wrong put controller logic in BFF Views. The intended way to combine BFF Records/Lists and Views into some kind or MVC-like pattern is as follows: Views listen to DOM events, and reacts to those by mutating data layer entities (such as models or lists of models) Views also listen to data layer events and reacts to those, possibly by further mutating the data layer (i.e. controller logic), but most importantly by re-rendering themselves. Another way of describing the above is that the views should, besides listening to user generated events, always strive to visually represent the data layer as truthfully as possible. A powerful and simple approach to achieving this is to re-render the whole view whenever the data layer changes. The three major issues to deal with when re-rendering an entire view are: Loss of view state. This is a generic problem, that thankfully has an easy solution; store all application state in the data layer. A typical way of doing this is to assign a view state model to views that are not stateless. Loss of event listeners. The typical solution to this is event delegation, which is also the soliution that BFF Views provide. All event listeners are registered on the view's root element and as long as the root elements is not replaced, the event listeners will be unaffecte by a re-render. Visual flickering. Replacing large chunks of the visual DOM may cause flickering. BFF Views work around this issue by using an approach similar to that of React, namely by differentially updating the DOM. This means doing an offline diff and then only updating the parts of the DOM that have actually changed. new (require(&quot;bff/view&quot;))() Creates a new View instance. Mixes In: module:bff/event-emitter module:bff/event-listener Source: view.js, line 39 Members children :module:bff/list A list of this view's child views. Initially empty. Type: module:bff/list Source: view.js, line 77 el :HTMLElement|undefined The root DOM element of the view. The default implementation of module:bff/view#render assigns to and updates this element. Delegated event listeners, created by calling module:bff/view#listenTo are attached to this element.Replacing the current element with another will clear all currently delegated event listeners - it is usually a better approach update the element (using e.g. module:bff/patch-dom) instead of replacing it. Type: HTMLElement | undefined Source: view.js, line 57 Methods &lt;static&gt; makeSubclass(properties) Creates a subclass constructor function, that will create view instances with the properties (typically functions) provded to this function. Parameters: Name Type Description properties Object The properties with which the View subclass' prototype will be extended. Source: view.js, line 340 Returns: Type function $(queryString) Scoped query selector, that only queries this view's DOM subtree. Parameters: Name Type Description queryString string CSS selector string Source: view.js, line 179 addChild(childView [, optional]) Adds another view as a child to the view. A child view will be automatically added to this view's root element and destroyed whenever its parent view is destroyed. Parameters: Name Type Argument Description childView module:bff/view The view that will be added to the list of this view's children. optional HTMLElement | boolean &lt;optional&gt; An element to which the child view's root element will be appended. If not specified, it will be appended to this view's root element. Can also be false, in which case the child view will not be appended to anything. Source: view.js, line 206 destroy() Destroys a view instance by removing its children, stop listening to all events and finally removing itself from the DOM. Source: view.js, line 97 destroyChildren() Destroy all child views of this view. Source: view.js, line 225 forceRepaint( [el]) Helper function that forces the view's root element to be repainted. Useful when re-triggering CSS animations. Parameters: Name Type Argument Description el HTMLElement &lt;optional&gt; Element that will be forced to repaint. If not specified, will default to the view's root element. Source: view.js, line 193 Returns: Useless/arbitrary value, but the function needs to return it to prevent browser JS optimizations from interfering with the forced repaint. Type number listenTo(selectorStr, eventName, callback [, context]) Augments bff/event-listener#listenTo with functionality for listening to delegated DOM events, by specifying a CSS selector string instead of an event emitter. The actual listener will implicitly be registered on this view's root element. Not the the &quot;mouseenter&quot; and &quot;mouseleave&quot; events does not bubble, so they might not behave as expected - &quot;mouseover&quot; and &quot;mouseout&quot; events on the other hand do bubble. Parameters: Name Type Argument Description selectorStr string | Object | Array | NodeList The CSS selector string that will be used to filter all events bubbling up to the listener. If anything other than a string passed, the original listenTo implementation will be used. eventName string | Array One or more string identifiers for events that will be listented to. callback function The function that will be called when the event is emitted. context any &lt;optional&gt; The context with which the callback will be called (i.e. what &quot;this&quot; will be). Will default to the caller of .listenTo, if not provided. Source: view.js, line 241 parseHtml(htmlString, returnAll) Helper function that parses an HTML string into an HTMLElement hierarchy and returns the first element in the NodeList, unless the returnAll flag is true, in which case the whole node list is returned. Parameters: Name Type Description htmlString string The string to be parsed returnAll boolean If true will return all top level elements Source: view.js, line 150 render( [patchOptions]) Creates a DOM representation of the view, based on the HTML string returned by the getHtml() function and then assigns it to the view's el property. If the view already has an el, it will be patched instead of replaced, so that delegated event listeners will be preserved. Parameters: Name Type Argument Description patchOptions Object &lt;optional&gt; Options object forwarded to the patch() function, in case it is called. Source: view.js, line 109 requestRender() Requests an animation frame, in which render() is called. Can be called several times during a tick witout any performance penalty. Source: view.js, line 133 stopListening( [selectorStr] [, eventName]) Augments bff/event-listener#stopListening with functionality for stop listening to delegated DOM events. Parameters: Name Type Argument Description selectorStr string | Object &lt;optional&gt; If provided, only delegated event callbacks for the given selector string will be removed. The special wildcard value * means any selector. If anything other than a string passed, the original stopListening implementation will be used. eventName string &lt;optional&gt; If provided, only callbacks attached to the given event name will be removed. Source: view.js, line 282 toString() Source: view.js, line 320 Returns: A human readable representation of the View, containing valuable debugging information. Type string × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
